// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package minimock

//go:generate minimock -i server/internal/service/users.Service -o mock_users.go -n UsersMock -p minimock

import (
	"server/internal/entities"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UsersMock implements users.Service
type UsersMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAuthorization          func(mail string, password string) (err error)
	inspectFuncAuthorization   func(mail string, password string)
	afterAuthorizationCounter  uint64
	beforeAuthorizationCounter uint64
	AuthorizationMock          mUsersMockAuthorization

	funcDeleteComment          func(postId int, commentId int) (err error)
	inspectFuncDeleteComment   func(postId int, commentId int)
	afterDeleteCommentCounter  uint64
	beforeDeleteCommentCounter uint64
	DeleteCommentMock          mUsersMockDeleteComment

	funcDeletePost          func(postId int) (err error)
	inspectFuncDeletePost   func(postId int)
	afterDeletePostCounter  uint64
	beforeDeletePostCounter uint64
	DeletePostMock          mUsersMockDeletePost

	funcEditPost          func(id int, header *string, body *string) (err error)
	inspectFuncEditPost   func(id int, header *string, body *string)
	afterEditPostCounter  uint64
	beforeEditPostCounter uint64
	EditPostMock          mUsersMockEditPost

	funcGetComment          func(postId int, commentId int) (cp1 *entities.Comment, err error)
	inspectFuncGetComment   func(postId int, commentId int)
	afterGetCommentCounter  uint64
	beforeGetCommentCounter uint64
	GetCommentMock          mUsersMockGetComment

	funcGetComments          func(postId int) (pa1 []interface{}, err error)
	inspectFuncGetComments   func(postId int)
	afterGetCommentsCounter  uint64
	beforeGetCommentsCounter uint64
	GetCommentsMock          mUsersMockGetComments

	funcGetPost          func(postId int) (pp1 *entities.Post, err error)
	inspectFuncGetPost   func(postId int)
	afterGetPostCounter  uint64
	beforeGetPostCounter uint64
	GetPostMock          mUsersMockGetPost

	funcGetPosts          func() (pa1 []interface{})
	inspectFuncGetPosts   func()
	afterGetPostsCounter  uint64
	beforeGetPostsCounter uint64
	GetPostsMock          mUsersMockGetPosts

	funcGetProfile          func(mail string) (up1 *entities.User, err error)
	inspectFuncGetProfile   func(mail string)
	afterGetProfileCounter  uint64
	beforeGetProfileCounter uint64
	GetProfileMock          mUsersMockGetProfile

	funcRegister          func(name string, mail string, password string) (err error)
	inspectFuncRegister   func(name string, mail string, password string)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mUsersMockRegister

	funcWriteComment          func(text *string, date time.Time, authorMail string, postId int) (err error)
	inspectFuncWriteComment   func(text *string, date time.Time, authorMail string, postId int)
	afterWriteCommentCounter  uint64
	beforeWriteCommentCounter uint64
	WriteCommentMock          mUsersMockWriteComment

	funcWritePost          func(header *string, body *string, date time.Time, authorMail string) (i1 int, err error)
	inspectFuncWritePost   func(header *string, body *string, date time.Time, authorMail string)
	afterWritePostCounter  uint64
	beforeWritePostCounter uint64
	WritePostMock          mUsersMockWritePost
}

// NewUsersMock returns a mock for users.Service
func NewUsersMock(t minimock.Tester) *UsersMock {
	m := &UsersMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AuthorizationMock = mUsersMockAuthorization{mock: m}
	m.AuthorizationMock.callArgs = []*UsersMockAuthorizationParams{}

	m.DeleteCommentMock = mUsersMockDeleteComment{mock: m}
	m.DeleteCommentMock.callArgs = []*UsersMockDeleteCommentParams{}

	m.DeletePostMock = mUsersMockDeletePost{mock: m}
	m.DeletePostMock.callArgs = []*UsersMockDeletePostParams{}

	m.EditPostMock = mUsersMockEditPost{mock: m}
	m.EditPostMock.callArgs = []*UsersMockEditPostParams{}

	m.GetCommentMock = mUsersMockGetComment{mock: m}
	m.GetCommentMock.callArgs = []*UsersMockGetCommentParams{}

	m.GetCommentsMock = mUsersMockGetComments{mock: m}
	m.GetCommentsMock.callArgs = []*UsersMockGetCommentsParams{}

	m.GetPostMock = mUsersMockGetPost{mock: m}
	m.GetPostMock.callArgs = []*UsersMockGetPostParams{}

	m.GetPostsMock = mUsersMockGetPosts{mock: m}

	m.GetProfileMock = mUsersMockGetProfile{mock: m}
	m.GetProfileMock.callArgs = []*UsersMockGetProfileParams{}

	m.RegisterMock = mUsersMockRegister{mock: m}
	m.RegisterMock.callArgs = []*UsersMockRegisterParams{}

	m.WriteCommentMock = mUsersMockWriteComment{mock: m}
	m.WriteCommentMock.callArgs = []*UsersMockWriteCommentParams{}

	m.WritePostMock = mUsersMockWritePost{mock: m}
	m.WritePostMock.callArgs = []*UsersMockWritePostParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUsersMockAuthorization struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockAuthorizationExpectation
	expectations       []*UsersMockAuthorizationExpectation

	callArgs []*UsersMockAuthorizationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockAuthorizationExpectation specifies expectation struct of the Service.Authorization
type UsersMockAuthorizationExpectation struct {
	mock      *UsersMock
	params    *UsersMockAuthorizationParams
	paramPtrs *UsersMockAuthorizationParamPtrs
	results   *UsersMockAuthorizationResults
	Counter   uint64
}

// UsersMockAuthorizationParams contains parameters of the Service.Authorization
type UsersMockAuthorizationParams struct {
	mail     string
	password string
}

// UsersMockAuthorizationParamPtrs contains pointers to parameters of the Service.Authorization
type UsersMockAuthorizationParamPtrs struct {
	mail     *string
	password *string
}

// UsersMockAuthorizationResults contains results of the Service.Authorization
type UsersMockAuthorizationResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAuthorization *mUsersMockAuthorization) Optional() *mUsersMockAuthorization {
	mmAuthorization.optional = true
	return mmAuthorization
}

// Expect sets up expected params for Service.Authorization
func (mmAuthorization *mUsersMockAuthorization) Expect(mail string, password string) *mUsersMockAuthorization {
	if mmAuthorization.mock.funcAuthorization != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by Set")
	}

	if mmAuthorization.defaultExpectation == nil {
		mmAuthorization.defaultExpectation = &UsersMockAuthorizationExpectation{}
	}

	if mmAuthorization.defaultExpectation.paramPtrs != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by ExpectParams functions")
	}

	mmAuthorization.defaultExpectation.params = &UsersMockAuthorizationParams{mail, password}
	for _, e := range mmAuthorization.expectations {
		if minimock.Equal(e.params, mmAuthorization.defaultExpectation.params) {
			mmAuthorization.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAuthorization.defaultExpectation.params)
		}
	}

	return mmAuthorization
}

// ExpectMailParam1 sets up expected param mail for Service.Authorization
func (mmAuthorization *mUsersMockAuthorization) ExpectMailParam1(mail string) *mUsersMockAuthorization {
	if mmAuthorization.mock.funcAuthorization != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by Set")
	}

	if mmAuthorization.defaultExpectation == nil {
		mmAuthorization.defaultExpectation = &UsersMockAuthorizationExpectation{}
	}

	if mmAuthorization.defaultExpectation.params != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by Expect")
	}

	if mmAuthorization.defaultExpectation.paramPtrs == nil {
		mmAuthorization.defaultExpectation.paramPtrs = &UsersMockAuthorizationParamPtrs{}
	}
	mmAuthorization.defaultExpectation.paramPtrs.mail = &mail

	return mmAuthorization
}

// ExpectPasswordParam2 sets up expected param password for Service.Authorization
func (mmAuthorization *mUsersMockAuthorization) ExpectPasswordParam2(password string) *mUsersMockAuthorization {
	if mmAuthorization.mock.funcAuthorization != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by Set")
	}

	if mmAuthorization.defaultExpectation == nil {
		mmAuthorization.defaultExpectation = &UsersMockAuthorizationExpectation{}
	}

	if mmAuthorization.defaultExpectation.params != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by Expect")
	}

	if mmAuthorization.defaultExpectation.paramPtrs == nil {
		mmAuthorization.defaultExpectation.paramPtrs = &UsersMockAuthorizationParamPtrs{}
	}
	mmAuthorization.defaultExpectation.paramPtrs.password = &password

	return mmAuthorization
}

// Inspect accepts an inspector function that has same arguments as the Service.Authorization
func (mmAuthorization *mUsersMockAuthorization) Inspect(f func(mail string, password string)) *mUsersMockAuthorization {
	if mmAuthorization.mock.inspectFuncAuthorization != nil {
		mmAuthorization.mock.t.Fatalf("Inspect function is already set for UsersMock.Authorization")
	}

	mmAuthorization.mock.inspectFuncAuthorization = f

	return mmAuthorization
}

// Return sets up results that will be returned by Service.Authorization
func (mmAuthorization *mUsersMockAuthorization) Return(err error) *UsersMock {
	if mmAuthorization.mock.funcAuthorization != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by Set")
	}

	if mmAuthorization.defaultExpectation == nil {
		mmAuthorization.defaultExpectation = &UsersMockAuthorizationExpectation{mock: mmAuthorization.mock}
	}
	mmAuthorization.defaultExpectation.results = &UsersMockAuthorizationResults{err}
	return mmAuthorization.mock
}

// Set uses given function f to mock the Service.Authorization method
func (mmAuthorization *mUsersMockAuthorization) Set(f func(mail string, password string) (err error)) *UsersMock {
	if mmAuthorization.defaultExpectation != nil {
		mmAuthorization.mock.t.Fatalf("Default expectation is already set for the Service.Authorization method")
	}

	if len(mmAuthorization.expectations) > 0 {
		mmAuthorization.mock.t.Fatalf("Some expectations are already set for the Service.Authorization method")
	}

	mmAuthorization.mock.funcAuthorization = f
	return mmAuthorization.mock
}

// When sets expectation for the Service.Authorization which will trigger the result defined by the following
// Then helper
func (mmAuthorization *mUsersMockAuthorization) When(mail string, password string) *UsersMockAuthorizationExpectation {
	if mmAuthorization.mock.funcAuthorization != nil {
		mmAuthorization.mock.t.Fatalf("UsersMock.Authorization mock is already set by Set")
	}

	expectation := &UsersMockAuthorizationExpectation{
		mock:   mmAuthorization.mock,
		params: &UsersMockAuthorizationParams{mail, password},
	}
	mmAuthorization.expectations = append(mmAuthorization.expectations, expectation)
	return expectation
}

// Then sets up Service.Authorization return parameters for the expectation previously defined by the When method
func (e *UsersMockAuthorizationExpectation) Then(err error) *UsersMock {
	e.results = &UsersMockAuthorizationResults{err}
	return e.mock
}

// Times sets number of times Service.Authorization should be invoked
func (mmAuthorization *mUsersMockAuthorization) Times(n uint64) *mUsersMockAuthorization {
	if n == 0 {
		mmAuthorization.mock.t.Fatalf("Times of UsersMock.Authorization mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAuthorization.expectedInvocations, n)
	return mmAuthorization
}

func (mmAuthorization *mUsersMockAuthorization) invocationsDone() bool {
	if len(mmAuthorization.expectations) == 0 && mmAuthorization.defaultExpectation == nil && mmAuthorization.mock.funcAuthorization == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAuthorization.mock.afterAuthorizationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAuthorization.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Authorization implements users.Service
func (mmAuthorization *UsersMock) Authorization(mail string, password string) (err error) {
	mm_atomic.AddUint64(&mmAuthorization.beforeAuthorizationCounter, 1)
	defer mm_atomic.AddUint64(&mmAuthorization.afterAuthorizationCounter, 1)

	if mmAuthorization.inspectFuncAuthorization != nil {
		mmAuthorization.inspectFuncAuthorization(mail, password)
	}

	mm_params := UsersMockAuthorizationParams{mail, password}

	// Record call args
	mmAuthorization.AuthorizationMock.mutex.Lock()
	mmAuthorization.AuthorizationMock.callArgs = append(mmAuthorization.AuthorizationMock.callArgs, &mm_params)
	mmAuthorization.AuthorizationMock.mutex.Unlock()

	for _, e := range mmAuthorization.AuthorizationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAuthorization.AuthorizationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAuthorization.AuthorizationMock.defaultExpectation.Counter, 1)
		mm_want := mmAuthorization.AuthorizationMock.defaultExpectation.params
		mm_want_ptrs := mmAuthorization.AuthorizationMock.defaultExpectation.paramPtrs

		mm_got := UsersMockAuthorizationParams{mail, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.mail != nil && !minimock.Equal(*mm_want_ptrs.mail, mm_got.mail) {
				mmAuthorization.t.Errorf("UsersMock.Authorization got unexpected parameter mail, want: %#v, got: %#v%s\n", *mm_want_ptrs.mail, mm_got.mail, minimock.Diff(*mm_want_ptrs.mail, mm_got.mail))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmAuthorization.t.Errorf("UsersMock.Authorization got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAuthorization.t.Errorf("UsersMock.Authorization got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAuthorization.AuthorizationMock.defaultExpectation.results
		if mm_results == nil {
			mmAuthorization.t.Fatal("No results are set for the UsersMock.Authorization")
		}
		return (*mm_results).err
	}
	if mmAuthorization.funcAuthorization != nil {
		return mmAuthorization.funcAuthorization(mail, password)
	}
	mmAuthorization.t.Fatalf("Unexpected call to UsersMock.Authorization. %v %v", mail, password)
	return
}

// AuthorizationAfterCounter returns a count of finished UsersMock.Authorization invocations
func (mmAuthorization *UsersMock) AuthorizationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthorization.afterAuthorizationCounter)
}

// AuthorizationBeforeCounter returns a count of UsersMock.Authorization invocations
func (mmAuthorization *UsersMock) AuthorizationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthorization.beforeAuthorizationCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.Authorization.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAuthorization *mUsersMockAuthorization) Calls() []*UsersMockAuthorizationParams {
	mmAuthorization.mutex.RLock()

	argCopy := make([]*UsersMockAuthorizationParams, len(mmAuthorization.callArgs))
	copy(argCopy, mmAuthorization.callArgs)

	mmAuthorization.mutex.RUnlock()

	return argCopy
}

// MinimockAuthorizationDone returns true if the count of the Authorization invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockAuthorizationDone() bool {
	if m.AuthorizationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AuthorizationMock.invocationsDone()
}

// MinimockAuthorizationInspect logs each unmet expectation
func (m *UsersMock) MinimockAuthorizationInspect() {
	for _, e := range m.AuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.Authorization with params: %#v", *e.params)
		}
	}

	afterAuthorizationCounter := mm_atomic.LoadUint64(&m.afterAuthorizationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AuthorizationMock.defaultExpectation != nil && afterAuthorizationCounter < 1 {
		if m.AuthorizationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.Authorization")
		} else {
			m.t.Errorf("Expected call to UsersMock.Authorization with params: %#v", *m.AuthorizationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuthorization != nil && afterAuthorizationCounter < 1 {
		m.t.Error("Expected call to UsersMock.Authorization")
	}

	if !m.AuthorizationMock.invocationsDone() && afterAuthorizationCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.Authorization but found %d calls",
			mm_atomic.LoadUint64(&m.AuthorizationMock.expectedInvocations), afterAuthorizationCounter)
	}
}

type mUsersMockDeleteComment struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockDeleteCommentExpectation
	expectations       []*UsersMockDeleteCommentExpectation

	callArgs []*UsersMockDeleteCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockDeleteCommentExpectation specifies expectation struct of the Service.DeleteComment
type UsersMockDeleteCommentExpectation struct {
	mock      *UsersMock
	params    *UsersMockDeleteCommentParams
	paramPtrs *UsersMockDeleteCommentParamPtrs
	results   *UsersMockDeleteCommentResults
	Counter   uint64
}

// UsersMockDeleteCommentParams contains parameters of the Service.DeleteComment
type UsersMockDeleteCommentParams struct {
	postId    int
	commentId int
}

// UsersMockDeleteCommentParamPtrs contains pointers to parameters of the Service.DeleteComment
type UsersMockDeleteCommentParamPtrs struct {
	postId    *int
	commentId *int
}

// UsersMockDeleteCommentResults contains results of the Service.DeleteComment
type UsersMockDeleteCommentResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteComment *mUsersMockDeleteComment) Optional() *mUsersMockDeleteComment {
	mmDeleteComment.optional = true
	return mmDeleteComment
}

// Expect sets up expected params for Service.DeleteComment
func (mmDeleteComment *mUsersMockDeleteComment) Expect(postId int, commentId int) *mUsersMockDeleteComment {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &UsersMockDeleteCommentExpectation{}
	}

	if mmDeleteComment.defaultExpectation.paramPtrs != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by ExpectParams functions")
	}

	mmDeleteComment.defaultExpectation.params = &UsersMockDeleteCommentParams{postId, commentId}
	for _, e := range mmDeleteComment.expectations {
		if minimock.Equal(e.params, mmDeleteComment.defaultExpectation.params) {
			mmDeleteComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteComment.defaultExpectation.params)
		}
	}

	return mmDeleteComment
}

// ExpectPostIdParam1 sets up expected param postId for Service.DeleteComment
func (mmDeleteComment *mUsersMockDeleteComment) ExpectPostIdParam1(postId int) *mUsersMockDeleteComment {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &UsersMockDeleteCommentExpectation{}
	}

	if mmDeleteComment.defaultExpectation.params != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by Expect")
	}

	if mmDeleteComment.defaultExpectation.paramPtrs == nil {
		mmDeleteComment.defaultExpectation.paramPtrs = &UsersMockDeleteCommentParamPtrs{}
	}
	mmDeleteComment.defaultExpectation.paramPtrs.postId = &postId

	return mmDeleteComment
}

// ExpectCommentIdParam2 sets up expected param commentId for Service.DeleteComment
func (mmDeleteComment *mUsersMockDeleteComment) ExpectCommentIdParam2(commentId int) *mUsersMockDeleteComment {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &UsersMockDeleteCommentExpectation{}
	}

	if mmDeleteComment.defaultExpectation.params != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by Expect")
	}

	if mmDeleteComment.defaultExpectation.paramPtrs == nil {
		mmDeleteComment.defaultExpectation.paramPtrs = &UsersMockDeleteCommentParamPtrs{}
	}
	mmDeleteComment.defaultExpectation.paramPtrs.commentId = &commentId

	return mmDeleteComment
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteComment
func (mmDeleteComment *mUsersMockDeleteComment) Inspect(f func(postId int, commentId int)) *mUsersMockDeleteComment {
	if mmDeleteComment.mock.inspectFuncDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("Inspect function is already set for UsersMock.DeleteComment")
	}

	mmDeleteComment.mock.inspectFuncDeleteComment = f

	return mmDeleteComment
}

// Return sets up results that will be returned by Service.DeleteComment
func (mmDeleteComment *mUsersMockDeleteComment) Return(err error) *UsersMock {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by Set")
	}

	if mmDeleteComment.defaultExpectation == nil {
		mmDeleteComment.defaultExpectation = &UsersMockDeleteCommentExpectation{mock: mmDeleteComment.mock}
	}
	mmDeleteComment.defaultExpectation.results = &UsersMockDeleteCommentResults{err}
	return mmDeleteComment.mock
}

// Set uses given function f to mock the Service.DeleteComment method
func (mmDeleteComment *mUsersMockDeleteComment) Set(f func(postId int, commentId int) (err error)) *UsersMock {
	if mmDeleteComment.defaultExpectation != nil {
		mmDeleteComment.mock.t.Fatalf("Default expectation is already set for the Service.DeleteComment method")
	}

	if len(mmDeleteComment.expectations) > 0 {
		mmDeleteComment.mock.t.Fatalf("Some expectations are already set for the Service.DeleteComment method")
	}

	mmDeleteComment.mock.funcDeleteComment = f
	return mmDeleteComment.mock
}

// When sets expectation for the Service.DeleteComment which will trigger the result defined by the following
// Then helper
func (mmDeleteComment *mUsersMockDeleteComment) When(postId int, commentId int) *UsersMockDeleteCommentExpectation {
	if mmDeleteComment.mock.funcDeleteComment != nil {
		mmDeleteComment.mock.t.Fatalf("UsersMock.DeleteComment mock is already set by Set")
	}

	expectation := &UsersMockDeleteCommentExpectation{
		mock:   mmDeleteComment.mock,
		params: &UsersMockDeleteCommentParams{postId, commentId},
	}
	mmDeleteComment.expectations = append(mmDeleteComment.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteComment return parameters for the expectation previously defined by the When method
func (e *UsersMockDeleteCommentExpectation) Then(err error) *UsersMock {
	e.results = &UsersMockDeleteCommentResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteComment should be invoked
func (mmDeleteComment *mUsersMockDeleteComment) Times(n uint64) *mUsersMockDeleteComment {
	if n == 0 {
		mmDeleteComment.mock.t.Fatalf("Times of UsersMock.DeleteComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteComment.expectedInvocations, n)
	return mmDeleteComment
}

func (mmDeleteComment *mUsersMockDeleteComment) invocationsDone() bool {
	if len(mmDeleteComment.expectations) == 0 && mmDeleteComment.defaultExpectation == nil && mmDeleteComment.mock.funcDeleteComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteComment.mock.afterDeleteCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteComment implements users.Service
func (mmDeleteComment *UsersMock) DeleteComment(postId int, commentId int) (err error) {
	mm_atomic.AddUint64(&mmDeleteComment.beforeDeleteCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteComment.afterDeleteCommentCounter, 1)

	if mmDeleteComment.inspectFuncDeleteComment != nil {
		mmDeleteComment.inspectFuncDeleteComment(postId, commentId)
	}

	mm_params := UsersMockDeleteCommentParams{postId, commentId}

	// Record call args
	mmDeleteComment.DeleteCommentMock.mutex.Lock()
	mmDeleteComment.DeleteCommentMock.callArgs = append(mmDeleteComment.DeleteCommentMock.callArgs, &mm_params)
	mmDeleteComment.DeleteCommentMock.mutex.Unlock()

	for _, e := range mmDeleteComment.DeleteCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteComment.DeleteCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteComment.DeleteCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteComment.DeleteCommentMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteComment.DeleteCommentMock.defaultExpectation.paramPtrs

		mm_got := UsersMockDeleteCommentParams{postId, commentId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmDeleteComment.t.Errorf("UsersMock.DeleteComment got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

			if mm_want_ptrs.commentId != nil && !minimock.Equal(*mm_want_ptrs.commentId, mm_got.commentId) {
				mmDeleteComment.t.Errorf("UsersMock.DeleteComment got unexpected parameter commentId, want: %#v, got: %#v%s\n", *mm_want_ptrs.commentId, mm_got.commentId, minimock.Diff(*mm_want_ptrs.commentId, mm_got.commentId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteComment.t.Errorf("UsersMock.DeleteComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteComment.DeleteCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteComment.t.Fatal("No results are set for the UsersMock.DeleteComment")
		}
		return (*mm_results).err
	}
	if mmDeleteComment.funcDeleteComment != nil {
		return mmDeleteComment.funcDeleteComment(postId, commentId)
	}
	mmDeleteComment.t.Fatalf("Unexpected call to UsersMock.DeleteComment. %v %v", postId, commentId)
	return
}

// DeleteCommentAfterCounter returns a count of finished UsersMock.DeleteComment invocations
func (mmDeleteComment *UsersMock) DeleteCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComment.afterDeleteCommentCounter)
}

// DeleteCommentBeforeCounter returns a count of UsersMock.DeleteComment invocations
func (mmDeleteComment *UsersMock) DeleteCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComment.beforeDeleteCommentCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.DeleteComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteComment *mUsersMockDeleteComment) Calls() []*UsersMockDeleteCommentParams {
	mmDeleteComment.mutex.RLock()

	argCopy := make([]*UsersMockDeleteCommentParams, len(mmDeleteComment.callArgs))
	copy(argCopy, mmDeleteComment.callArgs)

	mmDeleteComment.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCommentDone returns true if the count of the DeleteComment invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockDeleteCommentDone() bool {
	if m.DeleteCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCommentMock.invocationsDone()
}

// MinimockDeleteCommentInspect logs each unmet expectation
func (m *UsersMock) MinimockDeleteCommentInspect() {
	for _, e := range m.DeleteCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.DeleteComment with params: %#v", *e.params)
		}
	}

	afterDeleteCommentCounter := mm_atomic.LoadUint64(&m.afterDeleteCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCommentMock.defaultExpectation != nil && afterDeleteCommentCounter < 1 {
		if m.DeleteCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.DeleteComment")
		} else {
			m.t.Errorf("Expected call to UsersMock.DeleteComment with params: %#v", *m.DeleteCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteComment != nil && afterDeleteCommentCounter < 1 {
		m.t.Error("Expected call to UsersMock.DeleteComment")
	}

	if !m.DeleteCommentMock.invocationsDone() && afterDeleteCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.DeleteComment but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCommentMock.expectedInvocations), afterDeleteCommentCounter)
	}
}

type mUsersMockDeletePost struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockDeletePostExpectation
	expectations       []*UsersMockDeletePostExpectation

	callArgs []*UsersMockDeletePostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockDeletePostExpectation specifies expectation struct of the Service.DeletePost
type UsersMockDeletePostExpectation struct {
	mock      *UsersMock
	params    *UsersMockDeletePostParams
	paramPtrs *UsersMockDeletePostParamPtrs
	results   *UsersMockDeletePostResults
	Counter   uint64
}

// UsersMockDeletePostParams contains parameters of the Service.DeletePost
type UsersMockDeletePostParams struct {
	postId int
}

// UsersMockDeletePostParamPtrs contains pointers to parameters of the Service.DeletePost
type UsersMockDeletePostParamPtrs struct {
	postId *int
}

// UsersMockDeletePostResults contains results of the Service.DeletePost
type UsersMockDeletePostResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePost *mUsersMockDeletePost) Optional() *mUsersMockDeletePost {
	mmDeletePost.optional = true
	return mmDeletePost
}

// Expect sets up expected params for Service.DeletePost
func (mmDeletePost *mUsersMockDeletePost) Expect(postId int) *mUsersMockDeletePost {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("UsersMock.DeletePost mock is already set by Set")
	}

	if mmDeletePost.defaultExpectation == nil {
		mmDeletePost.defaultExpectation = &UsersMockDeletePostExpectation{}
	}

	if mmDeletePost.defaultExpectation.paramPtrs != nil {
		mmDeletePost.mock.t.Fatalf("UsersMock.DeletePost mock is already set by ExpectParams functions")
	}

	mmDeletePost.defaultExpectation.params = &UsersMockDeletePostParams{postId}
	for _, e := range mmDeletePost.expectations {
		if minimock.Equal(e.params, mmDeletePost.defaultExpectation.params) {
			mmDeletePost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePost.defaultExpectation.params)
		}
	}

	return mmDeletePost
}

// ExpectPostIdParam1 sets up expected param postId for Service.DeletePost
func (mmDeletePost *mUsersMockDeletePost) ExpectPostIdParam1(postId int) *mUsersMockDeletePost {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("UsersMock.DeletePost mock is already set by Set")
	}

	if mmDeletePost.defaultExpectation == nil {
		mmDeletePost.defaultExpectation = &UsersMockDeletePostExpectation{}
	}

	if mmDeletePost.defaultExpectation.params != nil {
		mmDeletePost.mock.t.Fatalf("UsersMock.DeletePost mock is already set by Expect")
	}

	if mmDeletePost.defaultExpectation.paramPtrs == nil {
		mmDeletePost.defaultExpectation.paramPtrs = &UsersMockDeletePostParamPtrs{}
	}
	mmDeletePost.defaultExpectation.paramPtrs.postId = &postId

	return mmDeletePost
}

// Inspect accepts an inspector function that has same arguments as the Service.DeletePost
func (mmDeletePost *mUsersMockDeletePost) Inspect(f func(postId int)) *mUsersMockDeletePost {
	if mmDeletePost.mock.inspectFuncDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("Inspect function is already set for UsersMock.DeletePost")
	}

	mmDeletePost.mock.inspectFuncDeletePost = f

	return mmDeletePost
}

// Return sets up results that will be returned by Service.DeletePost
func (mmDeletePost *mUsersMockDeletePost) Return(err error) *UsersMock {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("UsersMock.DeletePost mock is already set by Set")
	}

	if mmDeletePost.defaultExpectation == nil {
		mmDeletePost.defaultExpectation = &UsersMockDeletePostExpectation{mock: mmDeletePost.mock}
	}
	mmDeletePost.defaultExpectation.results = &UsersMockDeletePostResults{err}
	return mmDeletePost.mock
}

// Set uses given function f to mock the Service.DeletePost method
func (mmDeletePost *mUsersMockDeletePost) Set(f func(postId int) (err error)) *UsersMock {
	if mmDeletePost.defaultExpectation != nil {
		mmDeletePost.mock.t.Fatalf("Default expectation is already set for the Service.DeletePost method")
	}

	if len(mmDeletePost.expectations) > 0 {
		mmDeletePost.mock.t.Fatalf("Some expectations are already set for the Service.DeletePost method")
	}

	mmDeletePost.mock.funcDeletePost = f
	return mmDeletePost.mock
}

// When sets expectation for the Service.DeletePost which will trigger the result defined by the following
// Then helper
func (mmDeletePost *mUsersMockDeletePost) When(postId int) *UsersMockDeletePostExpectation {
	if mmDeletePost.mock.funcDeletePost != nil {
		mmDeletePost.mock.t.Fatalf("UsersMock.DeletePost mock is already set by Set")
	}

	expectation := &UsersMockDeletePostExpectation{
		mock:   mmDeletePost.mock,
		params: &UsersMockDeletePostParams{postId},
	}
	mmDeletePost.expectations = append(mmDeletePost.expectations, expectation)
	return expectation
}

// Then sets up Service.DeletePost return parameters for the expectation previously defined by the When method
func (e *UsersMockDeletePostExpectation) Then(err error) *UsersMock {
	e.results = &UsersMockDeletePostResults{err}
	return e.mock
}

// Times sets number of times Service.DeletePost should be invoked
func (mmDeletePost *mUsersMockDeletePost) Times(n uint64) *mUsersMockDeletePost {
	if n == 0 {
		mmDeletePost.mock.t.Fatalf("Times of UsersMock.DeletePost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePost.expectedInvocations, n)
	return mmDeletePost
}

func (mmDeletePost *mUsersMockDeletePost) invocationsDone() bool {
	if len(mmDeletePost.expectations) == 0 && mmDeletePost.defaultExpectation == nil && mmDeletePost.mock.funcDeletePost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePost.mock.afterDeletePostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePost implements users.Service
func (mmDeletePost *UsersMock) DeletePost(postId int) (err error) {
	mm_atomic.AddUint64(&mmDeletePost.beforeDeletePostCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePost.afterDeletePostCounter, 1)

	if mmDeletePost.inspectFuncDeletePost != nil {
		mmDeletePost.inspectFuncDeletePost(postId)
	}

	mm_params := UsersMockDeletePostParams{postId}

	// Record call args
	mmDeletePost.DeletePostMock.mutex.Lock()
	mmDeletePost.DeletePostMock.callArgs = append(mmDeletePost.DeletePostMock.callArgs, &mm_params)
	mmDeletePost.DeletePostMock.mutex.Unlock()

	for _, e := range mmDeletePost.DeletePostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePost.DeletePostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePost.DeletePostMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePost.DeletePostMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePost.DeletePostMock.defaultExpectation.paramPtrs

		mm_got := UsersMockDeletePostParams{postId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmDeletePost.t.Errorf("UsersMock.DeletePost got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePost.t.Errorf("UsersMock.DeletePost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePost.DeletePostMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePost.t.Fatal("No results are set for the UsersMock.DeletePost")
		}
		return (*mm_results).err
	}
	if mmDeletePost.funcDeletePost != nil {
		return mmDeletePost.funcDeletePost(postId)
	}
	mmDeletePost.t.Fatalf("Unexpected call to UsersMock.DeletePost. %v", postId)
	return
}

// DeletePostAfterCounter returns a count of finished UsersMock.DeletePost invocations
func (mmDeletePost *UsersMock) DeletePostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePost.afterDeletePostCounter)
}

// DeletePostBeforeCounter returns a count of UsersMock.DeletePost invocations
func (mmDeletePost *UsersMock) DeletePostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePost.beforeDeletePostCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.DeletePost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePost *mUsersMockDeletePost) Calls() []*UsersMockDeletePostParams {
	mmDeletePost.mutex.RLock()

	argCopy := make([]*UsersMockDeletePostParams, len(mmDeletePost.callArgs))
	copy(argCopy, mmDeletePost.callArgs)

	mmDeletePost.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePostDone returns true if the count of the DeletePost invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockDeletePostDone() bool {
	if m.DeletePostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePostMock.invocationsDone()
}

// MinimockDeletePostInspect logs each unmet expectation
func (m *UsersMock) MinimockDeletePostInspect() {
	for _, e := range m.DeletePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.DeletePost with params: %#v", *e.params)
		}
	}

	afterDeletePostCounter := mm_atomic.LoadUint64(&m.afterDeletePostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePostMock.defaultExpectation != nil && afterDeletePostCounter < 1 {
		if m.DeletePostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.DeletePost")
		} else {
			m.t.Errorf("Expected call to UsersMock.DeletePost with params: %#v", *m.DeletePostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePost != nil && afterDeletePostCounter < 1 {
		m.t.Error("Expected call to UsersMock.DeletePost")
	}

	if !m.DeletePostMock.invocationsDone() && afterDeletePostCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.DeletePost but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePostMock.expectedInvocations), afterDeletePostCounter)
	}
}

type mUsersMockEditPost struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockEditPostExpectation
	expectations       []*UsersMockEditPostExpectation

	callArgs []*UsersMockEditPostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockEditPostExpectation specifies expectation struct of the Service.EditPost
type UsersMockEditPostExpectation struct {
	mock      *UsersMock
	params    *UsersMockEditPostParams
	paramPtrs *UsersMockEditPostParamPtrs
	results   *UsersMockEditPostResults
	Counter   uint64
}

// UsersMockEditPostParams contains parameters of the Service.EditPost
type UsersMockEditPostParams struct {
	id     int
	header *string
	body   *string
}

// UsersMockEditPostParamPtrs contains pointers to parameters of the Service.EditPost
type UsersMockEditPostParamPtrs struct {
	id     *int
	header **string
	body   **string
}

// UsersMockEditPostResults contains results of the Service.EditPost
type UsersMockEditPostResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEditPost *mUsersMockEditPost) Optional() *mUsersMockEditPost {
	mmEditPost.optional = true
	return mmEditPost
}

// Expect sets up expected params for Service.EditPost
func (mmEditPost *mUsersMockEditPost) Expect(id int, header *string, body *string) *mUsersMockEditPost {
	if mmEditPost.mock.funcEditPost != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Set")
	}

	if mmEditPost.defaultExpectation == nil {
		mmEditPost.defaultExpectation = &UsersMockEditPostExpectation{}
	}

	if mmEditPost.defaultExpectation.paramPtrs != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by ExpectParams functions")
	}

	mmEditPost.defaultExpectation.params = &UsersMockEditPostParams{id, header, body}
	for _, e := range mmEditPost.expectations {
		if minimock.Equal(e.params, mmEditPost.defaultExpectation.params) {
			mmEditPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditPost.defaultExpectation.params)
		}
	}

	return mmEditPost
}

// ExpectIdParam1 sets up expected param id for Service.EditPost
func (mmEditPost *mUsersMockEditPost) ExpectIdParam1(id int) *mUsersMockEditPost {
	if mmEditPost.mock.funcEditPost != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Set")
	}

	if mmEditPost.defaultExpectation == nil {
		mmEditPost.defaultExpectation = &UsersMockEditPostExpectation{}
	}

	if mmEditPost.defaultExpectation.params != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Expect")
	}

	if mmEditPost.defaultExpectation.paramPtrs == nil {
		mmEditPost.defaultExpectation.paramPtrs = &UsersMockEditPostParamPtrs{}
	}
	mmEditPost.defaultExpectation.paramPtrs.id = &id

	return mmEditPost
}

// ExpectHeaderParam2 sets up expected param header for Service.EditPost
func (mmEditPost *mUsersMockEditPost) ExpectHeaderParam2(header *string) *mUsersMockEditPost {
	if mmEditPost.mock.funcEditPost != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Set")
	}

	if mmEditPost.defaultExpectation == nil {
		mmEditPost.defaultExpectation = &UsersMockEditPostExpectation{}
	}

	if mmEditPost.defaultExpectation.params != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Expect")
	}

	if mmEditPost.defaultExpectation.paramPtrs == nil {
		mmEditPost.defaultExpectation.paramPtrs = &UsersMockEditPostParamPtrs{}
	}
	mmEditPost.defaultExpectation.paramPtrs.header = &header

	return mmEditPost
}

// ExpectBodyParam3 sets up expected param body for Service.EditPost
func (mmEditPost *mUsersMockEditPost) ExpectBodyParam3(body *string) *mUsersMockEditPost {
	if mmEditPost.mock.funcEditPost != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Set")
	}

	if mmEditPost.defaultExpectation == nil {
		mmEditPost.defaultExpectation = &UsersMockEditPostExpectation{}
	}

	if mmEditPost.defaultExpectation.params != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Expect")
	}

	if mmEditPost.defaultExpectation.paramPtrs == nil {
		mmEditPost.defaultExpectation.paramPtrs = &UsersMockEditPostParamPtrs{}
	}
	mmEditPost.defaultExpectation.paramPtrs.body = &body

	return mmEditPost
}

// Inspect accepts an inspector function that has same arguments as the Service.EditPost
func (mmEditPost *mUsersMockEditPost) Inspect(f func(id int, header *string, body *string)) *mUsersMockEditPost {
	if mmEditPost.mock.inspectFuncEditPost != nil {
		mmEditPost.mock.t.Fatalf("Inspect function is already set for UsersMock.EditPost")
	}

	mmEditPost.mock.inspectFuncEditPost = f

	return mmEditPost
}

// Return sets up results that will be returned by Service.EditPost
func (mmEditPost *mUsersMockEditPost) Return(err error) *UsersMock {
	if mmEditPost.mock.funcEditPost != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Set")
	}

	if mmEditPost.defaultExpectation == nil {
		mmEditPost.defaultExpectation = &UsersMockEditPostExpectation{mock: mmEditPost.mock}
	}
	mmEditPost.defaultExpectation.results = &UsersMockEditPostResults{err}
	return mmEditPost.mock
}

// Set uses given function f to mock the Service.EditPost method
func (mmEditPost *mUsersMockEditPost) Set(f func(id int, header *string, body *string) (err error)) *UsersMock {
	if mmEditPost.defaultExpectation != nil {
		mmEditPost.mock.t.Fatalf("Default expectation is already set for the Service.EditPost method")
	}

	if len(mmEditPost.expectations) > 0 {
		mmEditPost.mock.t.Fatalf("Some expectations are already set for the Service.EditPost method")
	}

	mmEditPost.mock.funcEditPost = f
	return mmEditPost.mock
}

// When sets expectation for the Service.EditPost which will trigger the result defined by the following
// Then helper
func (mmEditPost *mUsersMockEditPost) When(id int, header *string, body *string) *UsersMockEditPostExpectation {
	if mmEditPost.mock.funcEditPost != nil {
		mmEditPost.mock.t.Fatalf("UsersMock.EditPost mock is already set by Set")
	}

	expectation := &UsersMockEditPostExpectation{
		mock:   mmEditPost.mock,
		params: &UsersMockEditPostParams{id, header, body},
	}
	mmEditPost.expectations = append(mmEditPost.expectations, expectation)
	return expectation
}

// Then sets up Service.EditPost return parameters for the expectation previously defined by the When method
func (e *UsersMockEditPostExpectation) Then(err error) *UsersMock {
	e.results = &UsersMockEditPostResults{err}
	return e.mock
}

// Times sets number of times Service.EditPost should be invoked
func (mmEditPost *mUsersMockEditPost) Times(n uint64) *mUsersMockEditPost {
	if n == 0 {
		mmEditPost.mock.t.Fatalf("Times of UsersMock.EditPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEditPost.expectedInvocations, n)
	return mmEditPost
}

func (mmEditPost *mUsersMockEditPost) invocationsDone() bool {
	if len(mmEditPost.expectations) == 0 && mmEditPost.defaultExpectation == nil && mmEditPost.mock.funcEditPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEditPost.mock.afterEditPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEditPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EditPost implements users.Service
func (mmEditPost *UsersMock) EditPost(id int, header *string, body *string) (err error) {
	mm_atomic.AddUint64(&mmEditPost.beforeEditPostCounter, 1)
	defer mm_atomic.AddUint64(&mmEditPost.afterEditPostCounter, 1)

	if mmEditPost.inspectFuncEditPost != nil {
		mmEditPost.inspectFuncEditPost(id, header, body)
	}

	mm_params := UsersMockEditPostParams{id, header, body}

	// Record call args
	mmEditPost.EditPostMock.mutex.Lock()
	mmEditPost.EditPostMock.callArgs = append(mmEditPost.EditPostMock.callArgs, &mm_params)
	mmEditPost.EditPostMock.mutex.Unlock()

	for _, e := range mmEditPost.EditPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditPost.EditPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditPost.EditPostMock.defaultExpectation.Counter, 1)
		mm_want := mmEditPost.EditPostMock.defaultExpectation.params
		mm_want_ptrs := mmEditPost.EditPostMock.defaultExpectation.paramPtrs

		mm_got := UsersMockEditPostParams{id, header, body}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmEditPost.t.Errorf("UsersMock.EditPost got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.header != nil && !minimock.Equal(*mm_want_ptrs.header, mm_got.header) {
				mmEditPost.t.Errorf("UsersMock.EditPost got unexpected parameter header, want: %#v, got: %#v%s\n", *mm_want_ptrs.header, mm_got.header, minimock.Diff(*mm_want_ptrs.header, mm_got.header))
			}

			if mm_want_ptrs.body != nil && !minimock.Equal(*mm_want_ptrs.body, mm_got.body) {
				mmEditPost.t.Errorf("UsersMock.EditPost got unexpected parameter body, want: %#v, got: %#v%s\n", *mm_want_ptrs.body, mm_got.body, minimock.Diff(*mm_want_ptrs.body, mm_got.body))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditPost.t.Errorf("UsersMock.EditPost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditPost.EditPostMock.defaultExpectation.results
		if mm_results == nil {
			mmEditPost.t.Fatal("No results are set for the UsersMock.EditPost")
		}
		return (*mm_results).err
	}
	if mmEditPost.funcEditPost != nil {
		return mmEditPost.funcEditPost(id, header, body)
	}
	mmEditPost.t.Fatalf("Unexpected call to UsersMock.EditPost. %v %v %v", id, header, body)
	return
}

// EditPostAfterCounter returns a count of finished UsersMock.EditPost invocations
func (mmEditPost *UsersMock) EditPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditPost.afterEditPostCounter)
}

// EditPostBeforeCounter returns a count of UsersMock.EditPost invocations
func (mmEditPost *UsersMock) EditPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditPost.beforeEditPostCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.EditPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditPost *mUsersMockEditPost) Calls() []*UsersMockEditPostParams {
	mmEditPost.mutex.RLock()

	argCopy := make([]*UsersMockEditPostParams, len(mmEditPost.callArgs))
	copy(argCopy, mmEditPost.callArgs)

	mmEditPost.mutex.RUnlock()

	return argCopy
}

// MinimockEditPostDone returns true if the count of the EditPost invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockEditPostDone() bool {
	if m.EditPostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EditPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EditPostMock.invocationsDone()
}

// MinimockEditPostInspect logs each unmet expectation
func (m *UsersMock) MinimockEditPostInspect() {
	for _, e := range m.EditPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.EditPost with params: %#v", *e.params)
		}
	}

	afterEditPostCounter := mm_atomic.LoadUint64(&m.afterEditPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EditPostMock.defaultExpectation != nil && afterEditPostCounter < 1 {
		if m.EditPostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.EditPost")
		} else {
			m.t.Errorf("Expected call to UsersMock.EditPost with params: %#v", *m.EditPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditPost != nil && afterEditPostCounter < 1 {
		m.t.Error("Expected call to UsersMock.EditPost")
	}

	if !m.EditPostMock.invocationsDone() && afterEditPostCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.EditPost but found %d calls",
			mm_atomic.LoadUint64(&m.EditPostMock.expectedInvocations), afterEditPostCounter)
	}
}

type mUsersMockGetComment struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockGetCommentExpectation
	expectations       []*UsersMockGetCommentExpectation

	callArgs []*UsersMockGetCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockGetCommentExpectation specifies expectation struct of the Service.GetComment
type UsersMockGetCommentExpectation struct {
	mock      *UsersMock
	params    *UsersMockGetCommentParams
	paramPtrs *UsersMockGetCommentParamPtrs
	results   *UsersMockGetCommentResults
	Counter   uint64
}

// UsersMockGetCommentParams contains parameters of the Service.GetComment
type UsersMockGetCommentParams struct {
	postId    int
	commentId int
}

// UsersMockGetCommentParamPtrs contains pointers to parameters of the Service.GetComment
type UsersMockGetCommentParamPtrs struct {
	postId    *int
	commentId *int
}

// UsersMockGetCommentResults contains results of the Service.GetComment
type UsersMockGetCommentResults struct {
	cp1 *entities.Comment
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetComment *mUsersMockGetComment) Optional() *mUsersMockGetComment {
	mmGetComment.optional = true
	return mmGetComment
}

// Expect sets up expected params for Service.GetComment
func (mmGetComment *mUsersMockGetComment) Expect(postId int, commentId int) *mUsersMockGetComment {
	if mmGetComment.mock.funcGetComment != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by Set")
	}

	if mmGetComment.defaultExpectation == nil {
		mmGetComment.defaultExpectation = &UsersMockGetCommentExpectation{}
	}

	if mmGetComment.defaultExpectation.paramPtrs != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by ExpectParams functions")
	}

	mmGetComment.defaultExpectation.params = &UsersMockGetCommentParams{postId, commentId}
	for _, e := range mmGetComment.expectations {
		if minimock.Equal(e.params, mmGetComment.defaultExpectation.params) {
			mmGetComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetComment.defaultExpectation.params)
		}
	}

	return mmGetComment
}

// ExpectPostIdParam1 sets up expected param postId for Service.GetComment
func (mmGetComment *mUsersMockGetComment) ExpectPostIdParam1(postId int) *mUsersMockGetComment {
	if mmGetComment.mock.funcGetComment != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by Set")
	}

	if mmGetComment.defaultExpectation == nil {
		mmGetComment.defaultExpectation = &UsersMockGetCommentExpectation{}
	}

	if mmGetComment.defaultExpectation.params != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by Expect")
	}

	if mmGetComment.defaultExpectation.paramPtrs == nil {
		mmGetComment.defaultExpectation.paramPtrs = &UsersMockGetCommentParamPtrs{}
	}
	mmGetComment.defaultExpectation.paramPtrs.postId = &postId

	return mmGetComment
}

// ExpectCommentIdParam2 sets up expected param commentId for Service.GetComment
func (mmGetComment *mUsersMockGetComment) ExpectCommentIdParam2(commentId int) *mUsersMockGetComment {
	if mmGetComment.mock.funcGetComment != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by Set")
	}

	if mmGetComment.defaultExpectation == nil {
		mmGetComment.defaultExpectation = &UsersMockGetCommentExpectation{}
	}

	if mmGetComment.defaultExpectation.params != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by Expect")
	}

	if mmGetComment.defaultExpectation.paramPtrs == nil {
		mmGetComment.defaultExpectation.paramPtrs = &UsersMockGetCommentParamPtrs{}
	}
	mmGetComment.defaultExpectation.paramPtrs.commentId = &commentId

	return mmGetComment
}

// Inspect accepts an inspector function that has same arguments as the Service.GetComment
func (mmGetComment *mUsersMockGetComment) Inspect(f func(postId int, commentId int)) *mUsersMockGetComment {
	if mmGetComment.mock.inspectFuncGetComment != nil {
		mmGetComment.mock.t.Fatalf("Inspect function is already set for UsersMock.GetComment")
	}

	mmGetComment.mock.inspectFuncGetComment = f

	return mmGetComment
}

// Return sets up results that will be returned by Service.GetComment
func (mmGetComment *mUsersMockGetComment) Return(cp1 *entities.Comment, err error) *UsersMock {
	if mmGetComment.mock.funcGetComment != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by Set")
	}

	if mmGetComment.defaultExpectation == nil {
		mmGetComment.defaultExpectation = &UsersMockGetCommentExpectation{mock: mmGetComment.mock}
	}
	mmGetComment.defaultExpectation.results = &UsersMockGetCommentResults{cp1, err}
	return mmGetComment.mock
}

// Set uses given function f to mock the Service.GetComment method
func (mmGetComment *mUsersMockGetComment) Set(f func(postId int, commentId int) (cp1 *entities.Comment, err error)) *UsersMock {
	if mmGetComment.defaultExpectation != nil {
		mmGetComment.mock.t.Fatalf("Default expectation is already set for the Service.GetComment method")
	}

	if len(mmGetComment.expectations) > 0 {
		mmGetComment.mock.t.Fatalf("Some expectations are already set for the Service.GetComment method")
	}

	mmGetComment.mock.funcGetComment = f
	return mmGetComment.mock
}

// When sets expectation for the Service.GetComment which will trigger the result defined by the following
// Then helper
func (mmGetComment *mUsersMockGetComment) When(postId int, commentId int) *UsersMockGetCommentExpectation {
	if mmGetComment.mock.funcGetComment != nil {
		mmGetComment.mock.t.Fatalf("UsersMock.GetComment mock is already set by Set")
	}

	expectation := &UsersMockGetCommentExpectation{
		mock:   mmGetComment.mock,
		params: &UsersMockGetCommentParams{postId, commentId},
	}
	mmGetComment.expectations = append(mmGetComment.expectations, expectation)
	return expectation
}

// Then sets up Service.GetComment return parameters for the expectation previously defined by the When method
func (e *UsersMockGetCommentExpectation) Then(cp1 *entities.Comment, err error) *UsersMock {
	e.results = &UsersMockGetCommentResults{cp1, err}
	return e.mock
}

// Times sets number of times Service.GetComment should be invoked
func (mmGetComment *mUsersMockGetComment) Times(n uint64) *mUsersMockGetComment {
	if n == 0 {
		mmGetComment.mock.t.Fatalf("Times of UsersMock.GetComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetComment.expectedInvocations, n)
	return mmGetComment
}

func (mmGetComment *mUsersMockGetComment) invocationsDone() bool {
	if len(mmGetComment.expectations) == 0 && mmGetComment.defaultExpectation == nil && mmGetComment.mock.funcGetComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetComment.mock.afterGetCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetComment implements users.Service
func (mmGetComment *UsersMock) GetComment(postId int, commentId int) (cp1 *entities.Comment, err error) {
	mm_atomic.AddUint64(&mmGetComment.beforeGetCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetComment.afterGetCommentCounter, 1)

	if mmGetComment.inspectFuncGetComment != nil {
		mmGetComment.inspectFuncGetComment(postId, commentId)
	}

	mm_params := UsersMockGetCommentParams{postId, commentId}

	// Record call args
	mmGetComment.GetCommentMock.mutex.Lock()
	mmGetComment.GetCommentMock.callArgs = append(mmGetComment.GetCommentMock.callArgs, &mm_params)
	mmGetComment.GetCommentMock.mutex.Unlock()

	for _, e := range mmGetComment.GetCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetComment.GetCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetComment.GetCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetComment.GetCommentMock.defaultExpectation.params
		mm_want_ptrs := mmGetComment.GetCommentMock.defaultExpectation.paramPtrs

		mm_got := UsersMockGetCommentParams{postId, commentId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmGetComment.t.Errorf("UsersMock.GetComment got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

			if mm_want_ptrs.commentId != nil && !minimock.Equal(*mm_want_ptrs.commentId, mm_got.commentId) {
				mmGetComment.t.Errorf("UsersMock.GetComment got unexpected parameter commentId, want: %#v, got: %#v%s\n", *mm_want_ptrs.commentId, mm_got.commentId, minimock.Diff(*mm_want_ptrs.commentId, mm_got.commentId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetComment.t.Errorf("UsersMock.GetComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetComment.GetCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetComment.t.Fatal("No results are set for the UsersMock.GetComment")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetComment.funcGetComment != nil {
		return mmGetComment.funcGetComment(postId, commentId)
	}
	mmGetComment.t.Fatalf("Unexpected call to UsersMock.GetComment. %v %v", postId, commentId)
	return
}

// GetCommentAfterCounter returns a count of finished UsersMock.GetComment invocations
func (mmGetComment *UsersMock) GetCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComment.afterGetCommentCounter)
}

// GetCommentBeforeCounter returns a count of UsersMock.GetComment invocations
func (mmGetComment *UsersMock) GetCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComment.beforeGetCommentCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.GetComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetComment *mUsersMockGetComment) Calls() []*UsersMockGetCommentParams {
	mmGetComment.mutex.RLock()

	argCopy := make([]*UsersMockGetCommentParams, len(mmGetComment.callArgs))
	copy(argCopy, mmGetComment.callArgs)

	mmGetComment.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentDone returns true if the count of the GetComment invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockGetCommentDone() bool {
	if m.GetCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentMock.invocationsDone()
}

// MinimockGetCommentInspect logs each unmet expectation
func (m *UsersMock) MinimockGetCommentInspect() {
	for _, e := range m.GetCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.GetComment with params: %#v", *e.params)
		}
	}

	afterGetCommentCounter := mm_atomic.LoadUint64(&m.afterGetCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentMock.defaultExpectation != nil && afterGetCommentCounter < 1 {
		if m.GetCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.GetComment")
		} else {
			m.t.Errorf("Expected call to UsersMock.GetComment with params: %#v", *m.GetCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetComment != nil && afterGetCommentCounter < 1 {
		m.t.Error("Expected call to UsersMock.GetComment")
	}

	if !m.GetCommentMock.invocationsDone() && afterGetCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.GetComment but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentMock.expectedInvocations), afterGetCommentCounter)
	}
}

type mUsersMockGetComments struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockGetCommentsExpectation
	expectations       []*UsersMockGetCommentsExpectation

	callArgs []*UsersMockGetCommentsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockGetCommentsExpectation specifies expectation struct of the Service.GetComments
type UsersMockGetCommentsExpectation struct {
	mock      *UsersMock
	params    *UsersMockGetCommentsParams
	paramPtrs *UsersMockGetCommentsParamPtrs
	results   *UsersMockGetCommentsResults
	Counter   uint64
}

// UsersMockGetCommentsParams contains parameters of the Service.GetComments
type UsersMockGetCommentsParams struct {
	postId int
}

// UsersMockGetCommentsParamPtrs contains pointers to parameters of the Service.GetComments
type UsersMockGetCommentsParamPtrs struct {
	postId *int
}

// UsersMockGetCommentsResults contains results of the Service.GetComments
type UsersMockGetCommentsResults struct {
	pa1 []interface{}
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetComments *mUsersMockGetComments) Optional() *mUsersMockGetComments {
	mmGetComments.optional = true
	return mmGetComments
}

// Expect sets up expected params for Service.GetComments
func (mmGetComments *mUsersMockGetComments) Expect(postId int) *mUsersMockGetComments {
	if mmGetComments.mock.funcGetComments != nil {
		mmGetComments.mock.t.Fatalf("UsersMock.GetComments mock is already set by Set")
	}

	if mmGetComments.defaultExpectation == nil {
		mmGetComments.defaultExpectation = &UsersMockGetCommentsExpectation{}
	}

	if mmGetComments.defaultExpectation.paramPtrs != nil {
		mmGetComments.mock.t.Fatalf("UsersMock.GetComments mock is already set by ExpectParams functions")
	}

	mmGetComments.defaultExpectation.params = &UsersMockGetCommentsParams{postId}
	for _, e := range mmGetComments.expectations {
		if minimock.Equal(e.params, mmGetComments.defaultExpectation.params) {
			mmGetComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetComments.defaultExpectation.params)
		}
	}

	return mmGetComments
}

// ExpectPostIdParam1 sets up expected param postId for Service.GetComments
func (mmGetComments *mUsersMockGetComments) ExpectPostIdParam1(postId int) *mUsersMockGetComments {
	if mmGetComments.mock.funcGetComments != nil {
		mmGetComments.mock.t.Fatalf("UsersMock.GetComments mock is already set by Set")
	}

	if mmGetComments.defaultExpectation == nil {
		mmGetComments.defaultExpectation = &UsersMockGetCommentsExpectation{}
	}

	if mmGetComments.defaultExpectation.params != nil {
		mmGetComments.mock.t.Fatalf("UsersMock.GetComments mock is already set by Expect")
	}

	if mmGetComments.defaultExpectation.paramPtrs == nil {
		mmGetComments.defaultExpectation.paramPtrs = &UsersMockGetCommentsParamPtrs{}
	}
	mmGetComments.defaultExpectation.paramPtrs.postId = &postId

	return mmGetComments
}

// Inspect accepts an inspector function that has same arguments as the Service.GetComments
func (mmGetComments *mUsersMockGetComments) Inspect(f func(postId int)) *mUsersMockGetComments {
	if mmGetComments.mock.inspectFuncGetComments != nil {
		mmGetComments.mock.t.Fatalf("Inspect function is already set for UsersMock.GetComments")
	}

	mmGetComments.mock.inspectFuncGetComments = f

	return mmGetComments
}

// Return sets up results that will be returned by Service.GetComments
func (mmGetComments *mUsersMockGetComments) Return(pa1 []interface{}, err error) *UsersMock {
	if mmGetComments.mock.funcGetComments != nil {
		mmGetComments.mock.t.Fatalf("UsersMock.GetComments mock is already set by Set")
	}

	if mmGetComments.defaultExpectation == nil {
		mmGetComments.defaultExpectation = &UsersMockGetCommentsExpectation{mock: mmGetComments.mock}
	}
	mmGetComments.defaultExpectation.results = &UsersMockGetCommentsResults{pa1, err}
	return mmGetComments.mock
}

// Set uses given function f to mock the Service.GetComments method
func (mmGetComments *mUsersMockGetComments) Set(f func(postId int) (pa1 []interface{}, err error)) *UsersMock {
	if mmGetComments.defaultExpectation != nil {
		mmGetComments.mock.t.Fatalf("Default expectation is already set for the Service.GetComments method")
	}

	if len(mmGetComments.expectations) > 0 {
		mmGetComments.mock.t.Fatalf("Some expectations are already set for the Service.GetComments method")
	}

	mmGetComments.mock.funcGetComments = f
	return mmGetComments.mock
}

// When sets expectation for the Service.GetComments which will trigger the result defined by the following
// Then helper
func (mmGetComments *mUsersMockGetComments) When(postId int) *UsersMockGetCommentsExpectation {
	if mmGetComments.mock.funcGetComments != nil {
		mmGetComments.mock.t.Fatalf("UsersMock.GetComments mock is already set by Set")
	}

	expectation := &UsersMockGetCommentsExpectation{
		mock:   mmGetComments.mock,
		params: &UsersMockGetCommentsParams{postId},
	}
	mmGetComments.expectations = append(mmGetComments.expectations, expectation)
	return expectation
}

// Then sets up Service.GetComments return parameters for the expectation previously defined by the When method
func (e *UsersMockGetCommentsExpectation) Then(pa1 []interface{}, err error) *UsersMock {
	e.results = &UsersMockGetCommentsResults{pa1, err}
	return e.mock
}

// Times sets number of times Service.GetComments should be invoked
func (mmGetComments *mUsersMockGetComments) Times(n uint64) *mUsersMockGetComments {
	if n == 0 {
		mmGetComments.mock.t.Fatalf("Times of UsersMock.GetComments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetComments.expectedInvocations, n)
	return mmGetComments
}

func (mmGetComments *mUsersMockGetComments) invocationsDone() bool {
	if len(mmGetComments.expectations) == 0 && mmGetComments.defaultExpectation == nil && mmGetComments.mock.funcGetComments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetComments.mock.afterGetCommentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetComments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetComments implements users.Service
func (mmGetComments *UsersMock) GetComments(postId int) (pa1 []interface{}, err error) {
	mm_atomic.AddUint64(&mmGetComments.beforeGetCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetComments.afterGetCommentsCounter, 1)

	if mmGetComments.inspectFuncGetComments != nil {
		mmGetComments.inspectFuncGetComments(postId)
	}

	mm_params := UsersMockGetCommentsParams{postId}

	// Record call args
	mmGetComments.GetCommentsMock.mutex.Lock()
	mmGetComments.GetCommentsMock.callArgs = append(mmGetComments.GetCommentsMock.callArgs, &mm_params)
	mmGetComments.GetCommentsMock.mutex.Unlock()

	for _, e := range mmGetComments.GetCommentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetComments.GetCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetComments.GetCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetComments.GetCommentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetComments.GetCommentsMock.defaultExpectation.paramPtrs

		mm_got := UsersMockGetCommentsParams{postId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmGetComments.t.Errorf("UsersMock.GetComments got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetComments.t.Errorf("UsersMock.GetComments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetComments.GetCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetComments.t.Fatal("No results are set for the UsersMock.GetComments")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetComments.funcGetComments != nil {
		return mmGetComments.funcGetComments(postId)
	}
	mmGetComments.t.Fatalf("Unexpected call to UsersMock.GetComments. %v", postId)
	return
}

// GetCommentsAfterCounter returns a count of finished UsersMock.GetComments invocations
func (mmGetComments *UsersMock) GetCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComments.afterGetCommentsCounter)
}

// GetCommentsBeforeCounter returns a count of UsersMock.GetComments invocations
func (mmGetComments *UsersMock) GetCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComments.beforeGetCommentsCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.GetComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetComments *mUsersMockGetComments) Calls() []*UsersMockGetCommentsParams {
	mmGetComments.mutex.RLock()

	argCopy := make([]*UsersMockGetCommentsParams, len(mmGetComments.callArgs))
	copy(argCopy, mmGetComments.callArgs)

	mmGetComments.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsDone returns true if the count of the GetComments invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockGetCommentsDone() bool {
	if m.GetCommentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentsMock.invocationsDone()
}

// MinimockGetCommentsInspect logs each unmet expectation
func (m *UsersMock) MinimockGetCommentsInspect() {
	for _, e := range m.GetCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.GetComments with params: %#v", *e.params)
		}
	}

	afterGetCommentsCounter := mm_atomic.LoadUint64(&m.afterGetCommentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsMock.defaultExpectation != nil && afterGetCommentsCounter < 1 {
		if m.GetCommentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.GetComments")
		} else {
			m.t.Errorf("Expected call to UsersMock.GetComments with params: %#v", *m.GetCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetComments != nil && afterGetCommentsCounter < 1 {
		m.t.Error("Expected call to UsersMock.GetComments")
	}

	if !m.GetCommentsMock.invocationsDone() && afterGetCommentsCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.GetComments but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentsMock.expectedInvocations), afterGetCommentsCounter)
	}
}

type mUsersMockGetPost struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockGetPostExpectation
	expectations       []*UsersMockGetPostExpectation

	callArgs []*UsersMockGetPostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockGetPostExpectation specifies expectation struct of the Service.GetPost
type UsersMockGetPostExpectation struct {
	mock      *UsersMock
	params    *UsersMockGetPostParams
	paramPtrs *UsersMockGetPostParamPtrs
	results   *UsersMockGetPostResults
	Counter   uint64
}

// UsersMockGetPostParams contains parameters of the Service.GetPost
type UsersMockGetPostParams struct {
	postId int
}

// UsersMockGetPostParamPtrs contains pointers to parameters of the Service.GetPost
type UsersMockGetPostParamPtrs struct {
	postId *int
}

// UsersMockGetPostResults contains results of the Service.GetPost
type UsersMockGetPostResults struct {
	pp1 *entities.Post
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPost *mUsersMockGetPost) Optional() *mUsersMockGetPost {
	mmGetPost.optional = true
	return mmGetPost
}

// Expect sets up expected params for Service.GetPost
func (mmGetPost *mUsersMockGetPost) Expect(postId int) *mUsersMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("UsersMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &UsersMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.paramPtrs != nil {
		mmGetPost.mock.t.Fatalf("UsersMock.GetPost mock is already set by ExpectParams functions")
	}

	mmGetPost.defaultExpectation.params = &UsersMockGetPostParams{postId}
	for _, e := range mmGetPost.expectations {
		if minimock.Equal(e.params, mmGetPost.defaultExpectation.params) {
			mmGetPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPost.defaultExpectation.params)
		}
	}

	return mmGetPost
}

// ExpectPostIdParam1 sets up expected param postId for Service.GetPost
func (mmGetPost *mUsersMockGetPost) ExpectPostIdParam1(postId int) *mUsersMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("UsersMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &UsersMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.params != nil {
		mmGetPost.mock.t.Fatalf("UsersMock.GetPost mock is already set by Expect")
	}

	if mmGetPost.defaultExpectation.paramPtrs == nil {
		mmGetPost.defaultExpectation.paramPtrs = &UsersMockGetPostParamPtrs{}
	}
	mmGetPost.defaultExpectation.paramPtrs.postId = &postId

	return mmGetPost
}

// Inspect accepts an inspector function that has same arguments as the Service.GetPost
func (mmGetPost *mUsersMockGetPost) Inspect(f func(postId int)) *mUsersMockGetPost {
	if mmGetPost.mock.inspectFuncGetPost != nil {
		mmGetPost.mock.t.Fatalf("Inspect function is already set for UsersMock.GetPost")
	}

	mmGetPost.mock.inspectFuncGetPost = f

	return mmGetPost
}

// Return sets up results that will be returned by Service.GetPost
func (mmGetPost *mUsersMockGetPost) Return(pp1 *entities.Post, err error) *UsersMock {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("UsersMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &UsersMockGetPostExpectation{mock: mmGetPost.mock}
	}
	mmGetPost.defaultExpectation.results = &UsersMockGetPostResults{pp1, err}
	return mmGetPost.mock
}

// Set uses given function f to mock the Service.GetPost method
func (mmGetPost *mUsersMockGetPost) Set(f func(postId int) (pp1 *entities.Post, err error)) *UsersMock {
	if mmGetPost.defaultExpectation != nil {
		mmGetPost.mock.t.Fatalf("Default expectation is already set for the Service.GetPost method")
	}

	if len(mmGetPost.expectations) > 0 {
		mmGetPost.mock.t.Fatalf("Some expectations are already set for the Service.GetPost method")
	}

	mmGetPost.mock.funcGetPost = f
	return mmGetPost.mock
}

// When sets expectation for the Service.GetPost which will trigger the result defined by the following
// Then helper
func (mmGetPost *mUsersMockGetPost) When(postId int) *UsersMockGetPostExpectation {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("UsersMock.GetPost mock is already set by Set")
	}

	expectation := &UsersMockGetPostExpectation{
		mock:   mmGetPost.mock,
		params: &UsersMockGetPostParams{postId},
	}
	mmGetPost.expectations = append(mmGetPost.expectations, expectation)
	return expectation
}

// Then sets up Service.GetPost return parameters for the expectation previously defined by the When method
func (e *UsersMockGetPostExpectation) Then(pp1 *entities.Post, err error) *UsersMock {
	e.results = &UsersMockGetPostResults{pp1, err}
	return e.mock
}

// Times sets number of times Service.GetPost should be invoked
func (mmGetPost *mUsersMockGetPost) Times(n uint64) *mUsersMockGetPost {
	if n == 0 {
		mmGetPost.mock.t.Fatalf("Times of UsersMock.GetPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPost.expectedInvocations, n)
	return mmGetPost
}

func (mmGetPost *mUsersMockGetPost) invocationsDone() bool {
	if len(mmGetPost.expectations) == 0 && mmGetPost.defaultExpectation == nil && mmGetPost.mock.funcGetPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPost.mock.afterGetPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPost implements users.Service
func (mmGetPost *UsersMock) GetPost(postId int) (pp1 *entities.Post, err error) {
	mm_atomic.AddUint64(&mmGetPost.beforeGetPostCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPost.afterGetPostCounter, 1)

	if mmGetPost.inspectFuncGetPost != nil {
		mmGetPost.inspectFuncGetPost(postId)
	}

	mm_params := UsersMockGetPostParams{postId}

	// Record call args
	mmGetPost.GetPostMock.mutex.Lock()
	mmGetPost.GetPostMock.callArgs = append(mmGetPost.GetPostMock.callArgs, &mm_params)
	mmGetPost.GetPostMock.mutex.Unlock()

	for _, e := range mmGetPost.GetPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPost.GetPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPost.GetPostMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPost.GetPostMock.defaultExpectation.params
		mm_want_ptrs := mmGetPost.GetPostMock.defaultExpectation.paramPtrs

		mm_got := UsersMockGetPostParams{postId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmGetPost.t.Errorf("UsersMock.GetPost got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPost.t.Errorf("UsersMock.GetPost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPost.GetPostMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPost.t.Fatal("No results are set for the UsersMock.GetPost")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPost.funcGetPost != nil {
		return mmGetPost.funcGetPost(postId)
	}
	mmGetPost.t.Fatalf("Unexpected call to UsersMock.GetPost. %v", postId)
	return
}

// GetPostAfterCounter returns a count of finished UsersMock.GetPost invocations
func (mmGetPost *UsersMock) GetPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.afterGetPostCounter)
}

// GetPostBeforeCounter returns a count of UsersMock.GetPost invocations
func (mmGetPost *UsersMock) GetPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.beforeGetPostCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.GetPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPost *mUsersMockGetPost) Calls() []*UsersMockGetPostParams {
	mmGetPost.mutex.RLock()

	argCopy := make([]*UsersMockGetPostParams, len(mmGetPost.callArgs))
	copy(argCopy, mmGetPost.callArgs)

	mmGetPost.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostDone returns true if the count of the GetPost invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockGetPostDone() bool {
	if m.GetPostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostMock.invocationsDone()
}

// MinimockGetPostInspect logs each unmet expectation
func (m *UsersMock) MinimockGetPostInspect() {
	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.GetPost with params: %#v", *e.params)
		}
	}

	afterGetPostCounter := mm_atomic.LoadUint64(&m.afterGetPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostMock.defaultExpectation != nil && afterGetPostCounter < 1 {
		if m.GetPostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.GetPost")
		} else {
			m.t.Errorf("Expected call to UsersMock.GetPost with params: %#v", *m.GetPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPost != nil && afterGetPostCounter < 1 {
		m.t.Error("Expected call to UsersMock.GetPost")
	}

	if !m.GetPostMock.invocationsDone() && afterGetPostCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.GetPost but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostMock.expectedInvocations), afterGetPostCounter)
	}
}

type mUsersMockGetPosts struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockGetPostsExpectation
	expectations       []*UsersMockGetPostsExpectation

	expectedInvocations uint64
}

// UsersMockGetPostsExpectation specifies expectation struct of the Service.GetPosts
type UsersMockGetPostsExpectation struct {
	mock *UsersMock

	results *UsersMockGetPostsResults
	Counter uint64
}

// UsersMockGetPostsResults contains results of the Service.GetPosts
type UsersMockGetPostsResults struct {
	pa1 []interface{}
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPosts *mUsersMockGetPosts) Optional() *mUsersMockGetPosts {
	mmGetPosts.optional = true
	return mmGetPosts
}

// Expect sets up expected params for Service.GetPosts
func (mmGetPosts *mUsersMockGetPosts) Expect() *mUsersMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("UsersMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &UsersMockGetPostsExpectation{}
	}

	return mmGetPosts
}

// Inspect accepts an inspector function that has same arguments as the Service.GetPosts
func (mmGetPosts *mUsersMockGetPosts) Inspect(f func()) *mUsersMockGetPosts {
	if mmGetPosts.mock.inspectFuncGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("Inspect function is already set for UsersMock.GetPosts")
	}

	mmGetPosts.mock.inspectFuncGetPosts = f

	return mmGetPosts
}

// Return sets up results that will be returned by Service.GetPosts
func (mmGetPosts *mUsersMockGetPosts) Return(pa1 []interface{}) *UsersMock {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("UsersMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &UsersMockGetPostsExpectation{mock: mmGetPosts.mock}
	}
	mmGetPosts.defaultExpectation.results = &UsersMockGetPostsResults{pa1}
	return mmGetPosts.mock
}

// Set uses given function f to mock the Service.GetPosts method
func (mmGetPosts *mUsersMockGetPosts) Set(f func() (pa1 []interface{})) *UsersMock {
	if mmGetPosts.defaultExpectation != nil {
		mmGetPosts.mock.t.Fatalf("Default expectation is already set for the Service.GetPosts method")
	}

	if len(mmGetPosts.expectations) > 0 {
		mmGetPosts.mock.t.Fatalf("Some expectations are already set for the Service.GetPosts method")
	}

	mmGetPosts.mock.funcGetPosts = f
	return mmGetPosts.mock
}

// Times sets number of times Service.GetPosts should be invoked
func (mmGetPosts *mUsersMockGetPosts) Times(n uint64) *mUsersMockGetPosts {
	if n == 0 {
		mmGetPosts.mock.t.Fatalf("Times of UsersMock.GetPosts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPosts.expectedInvocations, n)
	return mmGetPosts
}

func (mmGetPosts *mUsersMockGetPosts) invocationsDone() bool {
	if len(mmGetPosts.expectations) == 0 && mmGetPosts.defaultExpectation == nil && mmGetPosts.mock.funcGetPosts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPosts.mock.afterGetPostsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPosts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPosts implements users.Service
func (mmGetPosts *UsersMock) GetPosts() (pa1 []interface{}) {
	mm_atomic.AddUint64(&mmGetPosts.beforeGetPostsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPosts.afterGetPostsCounter, 1)

	if mmGetPosts.inspectFuncGetPosts != nil {
		mmGetPosts.inspectFuncGetPosts()
	}

	if mmGetPosts.GetPostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPosts.GetPostsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPosts.GetPostsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPosts.t.Fatal("No results are set for the UsersMock.GetPosts")
		}
		return (*mm_results).pa1
	}
	if mmGetPosts.funcGetPosts != nil {
		return mmGetPosts.funcGetPosts()
	}
	mmGetPosts.t.Fatalf("Unexpected call to UsersMock.GetPosts.")
	return
}

// GetPostsAfterCounter returns a count of finished UsersMock.GetPosts invocations
func (mmGetPosts *UsersMock) GetPostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.afterGetPostsCounter)
}

// GetPostsBeforeCounter returns a count of UsersMock.GetPosts invocations
func (mmGetPosts *UsersMock) GetPostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.beforeGetPostsCounter)
}

// MinimockGetPostsDone returns true if the count of the GetPosts invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockGetPostsDone() bool {
	if m.GetPostsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostsMock.invocationsDone()
}

// MinimockGetPostsInspect logs each unmet expectation
func (m *UsersMock) MinimockGetPostsInspect() {
	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to UsersMock.GetPosts")
		}
	}

	afterGetPostsCounter := mm_atomic.LoadUint64(&m.afterGetPostsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostsMock.defaultExpectation != nil && afterGetPostsCounter < 1 {
		m.t.Error("Expected call to UsersMock.GetPosts")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosts != nil && afterGetPostsCounter < 1 {
		m.t.Error("Expected call to UsersMock.GetPosts")
	}

	if !m.GetPostsMock.invocationsDone() && afterGetPostsCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.GetPosts but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostsMock.expectedInvocations), afterGetPostsCounter)
	}
}

type mUsersMockGetProfile struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockGetProfileExpectation
	expectations       []*UsersMockGetProfileExpectation

	callArgs []*UsersMockGetProfileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockGetProfileExpectation specifies expectation struct of the Service.GetProfile
type UsersMockGetProfileExpectation struct {
	mock      *UsersMock
	params    *UsersMockGetProfileParams
	paramPtrs *UsersMockGetProfileParamPtrs
	results   *UsersMockGetProfileResults
	Counter   uint64
}

// UsersMockGetProfileParams contains parameters of the Service.GetProfile
type UsersMockGetProfileParams struct {
	mail string
}

// UsersMockGetProfileParamPtrs contains pointers to parameters of the Service.GetProfile
type UsersMockGetProfileParamPtrs struct {
	mail *string
}

// UsersMockGetProfileResults contains results of the Service.GetProfile
type UsersMockGetProfileResults struct {
	up1 *entities.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProfile *mUsersMockGetProfile) Optional() *mUsersMockGetProfile {
	mmGetProfile.optional = true
	return mmGetProfile
}

// Expect sets up expected params for Service.GetProfile
func (mmGetProfile *mUsersMockGetProfile) Expect(mail string) *mUsersMockGetProfile {
	if mmGetProfile.mock.funcGetProfile != nil {
		mmGetProfile.mock.t.Fatalf("UsersMock.GetProfile mock is already set by Set")
	}

	if mmGetProfile.defaultExpectation == nil {
		mmGetProfile.defaultExpectation = &UsersMockGetProfileExpectation{}
	}

	if mmGetProfile.defaultExpectation.paramPtrs != nil {
		mmGetProfile.mock.t.Fatalf("UsersMock.GetProfile mock is already set by ExpectParams functions")
	}

	mmGetProfile.defaultExpectation.params = &UsersMockGetProfileParams{mail}
	for _, e := range mmGetProfile.expectations {
		if minimock.Equal(e.params, mmGetProfile.defaultExpectation.params) {
			mmGetProfile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProfile.defaultExpectation.params)
		}
	}

	return mmGetProfile
}

// ExpectMailParam1 sets up expected param mail for Service.GetProfile
func (mmGetProfile *mUsersMockGetProfile) ExpectMailParam1(mail string) *mUsersMockGetProfile {
	if mmGetProfile.mock.funcGetProfile != nil {
		mmGetProfile.mock.t.Fatalf("UsersMock.GetProfile mock is already set by Set")
	}

	if mmGetProfile.defaultExpectation == nil {
		mmGetProfile.defaultExpectation = &UsersMockGetProfileExpectation{}
	}

	if mmGetProfile.defaultExpectation.params != nil {
		mmGetProfile.mock.t.Fatalf("UsersMock.GetProfile mock is already set by Expect")
	}

	if mmGetProfile.defaultExpectation.paramPtrs == nil {
		mmGetProfile.defaultExpectation.paramPtrs = &UsersMockGetProfileParamPtrs{}
	}
	mmGetProfile.defaultExpectation.paramPtrs.mail = &mail

	return mmGetProfile
}

// Inspect accepts an inspector function that has same arguments as the Service.GetProfile
func (mmGetProfile *mUsersMockGetProfile) Inspect(f func(mail string)) *mUsersMockGetProfile {
	if mmGetProfile.mock.inspectFuncGetProfile != nil {
		mmGetProfile.mock.t.Fatalf("Inspect function is already set for UsersMock.GetProfile")
	}

	mmGetProfile.mock.inspectFuncGetProfile = f

	return mmGetProfile
}

// Return sets up results that will be returned by Service.GetProfile
func (mmGetProfile *mUsersMockGetProfile) Return(up1 *entities.User, err error) *UsersMock {
	if mmGetProfile.mock.funcGetProfile != nil {
		mmGetProfile.mock.t.Fatalf("UsersMock.GetProfile mock is already set by Set")
	}

	if mmGetProfile.defaultExpectation == nil {
		mmGetProfile.defaultExpectation = &UsersMockGetProfileExpectation{mock: mmGetProfile.mock}
	}
	mmGetProfile.defaultExpectation.results = &UsersMockGetProfileResults{up1, err}
	return mmGetProfile.mock
}

// Set uses given function f to mock the Service.GetProfile method
func (mmGetProfile *mUsersMockGetProfile) Set(f func(mail string) (up1 *entities.User, err error)) *UsersMock {
	if mmGetProfile.defaultExpectation != nil {
		mmGetProfile.mock.t.Fatalf("Default expectation is already set for the Service.GetProfile method")
	}

	if len(mmGetProfile.expectations) > 0 {
		mmGetProfile.mock.t.Fatalf("Some expectations are already set for the Service.GetProfile method")
	}

	mmGetProfile.mock.funcGetProfile = f
	return mmGetProfile.mock
}

// When sets expectation for the Service.GetProfile which will trigger the result defined by the following
// Then helper
func (mmGetProfile *mUsersMockGetProfile) When(mail string) *UsersMockGetProfileExpectation {
	if mmGetProfile.mock.funcGetProfile != nil {
		mmGetProfile.mock.t.Fatalf("UsersMock.GetProfile mock is already set by Set")
	}

	expectation := &UsersMockGetProfileExpectation{
		mock:   mmGetProfile.mock,
		params: &UsersMockGetProfileParams{mail},
	}
	mmGetProfile.expectations = append(mmGetProfile.expectations, expectation)
	return expectation
}

// Then sets up Service.GetProfile return parameters for the expectation previously defined by the When method
func (e *UsersMockGetProfileExpectation) Then(up1 *entities.User, err error) *UsersMock {
	e.results = &UsersMockGetProfileResults{up1, err}
	return e.mock
}

// Times sets number of times Service.GetProfile should be invoked
func (mmGetProfile *mUsersMockGetProfile) Times(n uint64) *mUsersMockGetProfile {
	if n == 0 {
		mmGetProfile.mock.t.Fatalf("Times of UsersMock.GetProfile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetProfile.expectedInvocations, n)
	return mmGetProfile
}

func (mmGetProfile *mUsersMockGetProfile) invocationsDone() bool {
	if len(mmGetProfile.expectations) == 0 && mmGetProfile.defaultExpectation == nil && mmGetProfile.mock.funcGetProfile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetProfile.mock.afterGetProfileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetProfile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetProfile implements users.Service
func (mmGetProfile *UsersMock) GetProfile(mail string) (up1 *entities.User, err error) {
	mm_atomic.AddUint64(&mmGetProfile.beforeGetProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProfile.afterGetProfileCounter, 1)

	if mmGetProfile.inspectFuncGetProfile != nil {
		mmGetProfile.inspectFuncGetProfile(mail)
	}

	mm_params := UsersMockGetProfileParams{mail}

	// Record call args
	mmGetProfile.GetProfileMock.mutex.Lock()
	mmGetProfile.GetProfileMock.callArgs = append(mmGetProfile.GetProfileMock.callArgs, &mm_params)
	mmGetProfile.GetProfileMock.mutex.Unlock()

	for _, e := range mmGetProfile.GetProfileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetProfile.GetProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProfile.GetProfileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProfile.GetProfileMock.defaultExpectation.params
		mm_want_ptrs := mmGetProfile.GetProfileMock.defaultExpectation.paramPtrs

		mm_got := UsersMockGetProfileParams{mail}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.mail != nil && !minimock.Equal(*mm_want_ptrs.mail, mm_got.mail) {
				mmGetProfile.t.Errorf("UsersMock.GetProfile got unexpected parameter mail, want: %#v, got: %#v%s\n", *mm_want_ptrs.mail, mm_got.mail, minimock.Diff(*mm_want_ptrs.mail, mm_got.mail))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProfile.t.Errorf("UsersMock.GetProfile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProfile.GetProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProfile.t.Fatal("No results are set for the UsersMock.GetProfile")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetProfile.funcGetProfile != nil {
		return mmGetProfile.funcGetProfile(mail)
	}
	mmGetProfile.t.Fatalf("Unexpected call to UsersMock.GetProfile. %v", mail)
	return
}

// GetProfileAfterCounter returns a count of finished UsersMock.GetProfile invocations
func (mmGetProfile *UsersMock) GetProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfile.afterGetProfileCounter)
}

// GetProfileBeforeCounter returns a count of UsersMock.GetProfile invocations
func (mmGetProfile *UsersMock) GetProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfile.beforeGetProfileCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.GetProfile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProfile *mUsersMockGetProfile) Calls() []*UsersMockGetProfileParams {
	mmGetProfile.mutex.RLock()

	argCopy := make([]*UsersMockGetProfileParams, len(mmGetProfile.callArgs))
	copy(argCopy, mmGetProfile.callArgs)

	mmGetProfile.mutex.RUnlock()

	return argCopy
}

// MinimockGetProfileDone returns true if the count of the GetProfile invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockGetProfileDone() bool {
	if m.GetProfileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetProfileMock.invocationsDone()
}

// MinimockGetProfileInspect logs each unmet expectation
func (m *UsersMock) MinimockGetProfileInspect() {
	for _, e := range m.GetProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.GetProfile with params: %#v", *e.params)
		}
	}

	afterGetProfileCounter := mm_atomic.LoadUint64(&m.afterGetProfileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfileMock.defaultExpectation != nil && afterGetProfileCounter < 1 {
		if m.GetProfileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.GetProfile")
		} else {
			m.t.Errorf("Expected call to UsersMock.GetProfile with params: %#v", *m.GetProfileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfile != nil && afterGetProfileCounter < 1 {
		m.t.Error("Expected call to UsersMock.GetProfile")
	}

	if !m.GetProfileMock.invocationsDone() && afterGetProfileCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.GetProfile but found %d calls",
			mm_atomic.LoadUint64(&m.GetProfileMock.expectedInvocations), afterGetProfileCounter)
	}
}

type mUsersMockRegister struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockRegisterExpectation
	expectations       []*UsersMockRegisterExpectation

	callArgs []*UsersMockRegisterParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockRegisterExpectation specifies expectation struct of the Service.Register
type UsersMockRegisterExpectation struct {
	mock      *UsersMock
	params    *UsersMockRegisterParams
	paramPtrs *UsersMockRegisterParamPtrs
	results   *UsersMockRegisterResults
	Counter   uint64
}

// UsersMockRegisterParams contains parameters of the Service.Register
type UsersMockRegisterParams struct {
	name     string
	mail     string
	password string
}

// UsersMockRegisterParamPtrs contains pointers to parameters of the Service.Register
type UsersMockRegisterParamPtrs struct {
	name     *string
	mail     *string
	password *string
}

// UsersMockRegisterResults contains results of the Service.Register
type UsersMockRegisterResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegister *mUsersMockRegister) Optional() *mUsersMockRegister {
	mmRegister.optional = true
	return mmRegister
}

// Expect sets up expected params for Service.Register
func (mmRegister *mUsersMockRegister) Expect(name string, mail string, password string) *mUsersMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UsersMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.paramPtrs != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by ExpectParams functions")
	}

	mmRegister.defaultExpectation.params = &UsersMockRegisterParams{name, mail, password}
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// ExpectNameParam1 sets up expected param name for Service.Register
func (mmRegister *mUsersMockRegister) ExpectNameParam1(name string) *mUsersMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UsersMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UsersMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.name = &name

	return mmRegister
}

// ExpectMailParam2 sets up expected param mail for Service.Register
func (mmRegister *mUsersMockRegister) ExpectMailParam2(mail string) *mUsersMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UsersMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UsersMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.mail = &mail

	return mmRegister
}

// ExpectPasswordParam3 sets up expected param password for Service.Register
func (mmRegister *mUsersMockRegister) ExpectPasswordParam3(password string) *mUsersMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UsersMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UsersMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.password = &password

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the Service.Register
func (mmRegister *mUsersMockRegister) Inspect(f func(name string, mail string, password string)) *mUsersMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for UsersMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by Service.Register
func (mmRegister *mUsersMockRegister) Return(err error) *UsersMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UsersMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &UsersMockRegisterResults{err}
	return mmRegister.mock
}

// Set uses given function f to mock the Service.Register method
func (mmRegister *mUsersMockRegister) Set(f func(name string, mail string, password string) (err error)) *UsersMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the Service.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the Service.Register method")
	}

	mmRegister.mock.funcRegister = f
	return mmRegister.mock
}

// When sets expectation for the Service.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mUsersMockRegister) When(name string, mail string, password string) *UsersMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UsersMock.Register mock is already set by Set")
	}

	expectation := &UsersMockRegisterExpectation{
		mock:   mmRegister.mock,
		params: &UsersMockRegisterParams{name, mail, password},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up Service.Register return parameters for the expectation previously defined by the When method
func (e *UsersMockRegisterExpectation) Then(err error) *UsersMock {
	e.results = &UsersMockRegisterResults{err}
	return e.mock
}

// Times sets number of times Service.Register should be invoked
func (mmRegister *mUsersMockRegister) Times(n uint64) *mUsersMockRegister {
	if n == 0 {
		mmRegister.mock.t.Fatalf("Times of UsersMock.Register mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegister.expectedInvocations, n)
	return mmRegister
}

func (mmRegister *mUsersMockRegister) invocationsDone() bool {
	if len(mmRegister.expectations) == 0 && mmRegister.defaultExpectation == nil && mmRegister.mock.funcRegister == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegister.mock.afterRegisterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegister.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Register implements users.Service
func (mmRegister *UsersMock) Register(name string, mail string, password string) (err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(name, mail, password)
	}

	mm_params := UsersMockRegisterParams{name, mail, password}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, &mm_params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegister.RegisterMock.defaultExpectation.params
		mm_want_ptrs := mmRegister.RegisterMock.defaultExpectation.paramPtrs

		mm_got := UsersMockRegisterParams{name, mail, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmRegister.t.Errorf("UsersMock.Register got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.mail != nil && !minimock.Equal(*mm_want_ptrs.mail, mm_got.mail) {
				mmRegister.t.Errorf("UsersMock.Register got unexpected parameter mail, want: %#v, got: %#v%s\n", *mm_want_ptrs.mail, mm_got.mail, minimock.Diff(*mm_want_ptrs.mail, mm_got.mail))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmRegister.t.Errorf("UsersMock.Register got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegister.t.Errorf("UsersMock.Register got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegister.RegisterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegister.t.Fatal("No results are set for the UsersMock.Register")
		}
		return (*mm_results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(name, mail, password)
	}
	mmRegister.t.Fatalf("Unexpected call to UsersMock.Register. %v %v %v", name, mail, password)
	return
}

// RegisterAfterCounter returns a count of finished UsersMock.Register invocations
func (mmRegister *UsersMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of UsersMock.Register invocations
func (mmRegister *UsersMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mUsersMockRegister) Calls() []*UsersMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*UsersMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockRegisterDone() bool {
	if m.RegisterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterMock.invocationsDone()
}

// MinimockRegisterInspect logs each unmet expectation
func (m *UsersMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.Register with params: %#v", *e.params)
		}
	}

	afterRegisterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && afterRegisterCounter < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.Register")
		} else {
			m.t.Errorf("Expected call to UsersMock.Register with params: %#v", *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && afterRegisterCounter < 1 {
		m.t.Error("Expected call to UsersMock.Register")
	}

	if !m.RegisterMock.invocationsDone() && afterRegisterCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.Register but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterMock.expectedInvocations), afterRegisterCounter)
	}
}

type mUsersMockWriteComment struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockWriteCommentExpectation
	expectations       []*UsersMockWriteCommentExpectation

	callArgs []*UsersMockWriteCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockWriteCommentExpectation specifies expectation struct of the Service.WriteComment
type UsersMockWriteCommentExpectation struct {
	mock      *UsersMock
	params    *UsersMockWriteCommentParams
	paramPtrs *UsersMockWriteCommentParamPtrs
	results   *UsersMockWriteCommentResults
	Counter   uint64
}

// UsersMockWriteCommentParams contains parameters of the Service.WriteComment
type UsersMockWriteCommentParams struct {
	text       *string
	date       time.Time
	authorMail string
	postId     int
}

// UsersMockWriteCommentParamPtrs contains pointers to parameters of the Service.WriteComment
type UsersMockWriteCommentParamPtrs struct {
	text       **string
	date       *time.Time
	authorMail *string
	postId     *int
}

// UsersMockWriteCommentResults contains results of the Service.WriteComment
type UsersMockWriteCommentResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteComment *mUsersMockWriteComment) Optional() *mUsersMockWriteComment {
	mmWriteComment.optional = true
	return mmWriteComment
}

// Expect sets up expected params for Service.WriteComment
func (mmWriteComment *mUsersMockWriteComment) Expect(text *string, date time.Time, authorMail string, postId int) *mUsersMockWriteComment {
	if mmWriteComment.mock.funcWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Set")
	}

	if mmWriteComment.defaultExpectation == nil {
		mmWriteComment.defaultExpectation = &UsersMockWriteCommentExpectation{}
	}

	if mmWriteComment.defaultExpectation.paramPtrs != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by ExpectParams functions")
	}

	mmWriteComment.defaultExpectation.params = &UsersMockWriteCommentParams{text, date, authorMail, postId}
	for _, e := range mmWriteComment.expectations {
		if minimock.Equal(e.params, mmWriteComment.defaultExpectation.params) {
			mmWriteComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteComment.defaultExpectation.params)
		}
	}

	return mmWriteComment
}

// ExpectTextParam1 sets up expected param text for Service.WriteComment
func (mmWriteComment *mUsersMockWriteComment) ExpectTextParam1(text *string) *mUsersMockWriteComment {
	if mmWriteComment.mock.funcWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Set")
	}

	if mmWriteComment.defaultExpectation == nil {
		mmWriteComment.defaultExpectation = &UsersMockWriteCommentExpectation{}
	}

	if mmWriteComment.defaultExpectation.params != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Expect")
	}

	if mmWriteComment.defaultExpectation.paramPtrs == nil {
		mmWriteComment.defaultExpectation.paramPtrs = &UsersMockWriteCommentParamPtrs{}
	}
	mmWriteComment.defaultExpectation.paramPtrs.text = &text

	return mmWriteComment
}

// ExpectDateParam2 sets up expected param date for Service.WriteComment
func (mmWriteComment *mUsersMockWriteComment) ExpectDateParam2(date time.Time) *mUsersMockWriteComment {
	if mmWriteComment.mock.funcWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Set")
	}

	if mmWriteComment.defaultExpectation == nil {
		mmWriteComment.defaultExpectation = &UsersMockWriteCommentExpectation{}
	}

	if mmWriteComment.defaultExpectation.params != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Expect")
	}

	if mmWriteComment.defaultExpectation.paramPtrs == nil {
		mmWriteComment.defaultExpectation.paramPtrs = &UsersMockWriteCommentParamPtrs{}
	}
	mmWriteComment.defaultExpectation.paramPtrs.date = &date

	return mmWriteComment
}

// ExpectAuthorMailParam3 sets up expected param authorMail for Service.WriteComment
func (mmWriteComment *mUsersMockWriteComment) ExpectAuthorMailParam3(authorMail string) *mUsersMockWriteComment {
	if mmWriteComment.mock.funcWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Set")
	}

	if mmWriteComment.defaultExpectation == nil {
		mmWriteComment.defaultExpectation = &UsersMockWriteCommentExpectation{}
	}

	if mmWriteComment.defaultExpectation.params != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Expect")
	}

	if mmWriteComment.defaultExpectation.paramPtrs == nil {
		mmWriteComment.defaultExpectation.paramPtrs = &UsersMockWriteCommentParamPtrs{}
	}
	mmWriteComment.defaultExpectation.paramPtrs.authorMail = &authorMail

	return mmWriteComment
}

// ExpectPostIdParam4 sets up expected param postId for Service.WriteComment
func (mmWriteComment *mUsersMockWriteComment) ExpectPostIdParam4(postId int) *mUsersMockWriteComment {
	if mmWriteComment.mock.funcWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Set")
	}

	if mmWriteComment.defaultExpectation == nil {
		mmWriteComment.defaultExpectation = &UsersMockWriteCommentExpectation{}
	}

	if mmWriteComment.defaultExpectation.params != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Expect")
	}

	if mmWriteComment.defaultExpectation.paramPtrs == nil {
		mmWriteComment.defaultExpectation.paramPtrs = &UsersMockWriteCommentParamPtrs{}
	}
	mmWriteComment.defaultExpectation.paramPtrs.postId = &postId

	return mmWriteComment
}

// Inspect accepts an inspector function that has same arguments as the Service.WriteComment
func (mmWriteComment *mUsersMockWriteComment) Inspect(f func(text *string, date time.Time, authorMail string, postId int)) *mUsersMockWriteComment {
	if mmWriteComment.mock.inspectFuncWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("Inspect function is already set for UsersMock.WriteComment")
	}

	mmWriteComment.mock.inspectFuncWriteComment = f

	return mmWriteComment
}

// Return sets up results that will be returned by Service.WriteComment
func (mmWriteComment *mUsersMockWriteComment) Return(err error) *UsersMock {
	if mmWriteComment.mock.funcWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Set")
	}

	if mmWriteComment.defaultExpectation == nil {
		mmWriteComment.defaultExpectation = &UsersMockWriteCommentExpectation{mock: mmWriteComment.mock}
	}
	mmWriteComment.defaultExpectation.results = &UsersMockWriteCommentResults{err}
	return mmWriteComment.mock
}

// Set uses given function f to mock the Service.WriteComment method
func (mmWriteComment *mUsersMockWriteComment) Set(f func(text *string, date time.Time, authorMail string, postId int) (err error)) *UsersMock {
	if mmWriteComment.defaultExpectation != nil {
		mmWriteComment.mock.t.Fatalf("Default expectation is already set for the Service.WriteComment method")
	}

	if len(mmWriteComment.expectations) > 0 {
		mmWriteComment.mock.t.Fatalf("Some expectations are already set for the Service.WriteComment method")
	}

	mmWriteComment.mock.funcWriteComment = f
	return mmWriteComment.mock
}

// When sets expectation for the Service.WriteComment which will trigger the result defined by the following
// Then helper
func (mmWriteComment *mUsersMockWriteComment) When(text *string, date time.Time, authorMail string, postId int) *UsersMockWriteCommentExpectation {
	if mmWriteComment.mock.funcWriteComment != nil {
		mmWriteComment.mock.t.Fatalf("UsersMock.WriteComment mock is already set by Set")
	}

	expectation := &UsersMockWriteCommentExpectation{
		mock:   mmWriteComment.mock,
		params: &UsersMockWriteCommentParams{text, date, authorMail, postId},
	}
	mmWriteComment.expectations = append(mmWriteComment.expectations, expectation)
	return expectation
}

// Then sets up Service.WriteComment return parameters for the expectation previously defined by the When method
func (e *UsersMockWriteCommentExpectation) Then(err error) *UsersMock {
	e.results = &UsersMockWriteCommentResults{err}
	return e.mock
}

// Times sets number of times Service.WriteComment should be invoked
func (mmWriteComment *mUsersMockWriteComment) Times(n uint64) *mUsersMockWriteComment {
	if n == 0 {
		mmWriteComment.mock.t.Fatalf("Times of UsersMock.WriteComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteComment.expectedInvocations, n)
	return mmWriteComment
}

func (mmWriteComment *mUsersMockWriteComment) invocationsDone() bool {
	if len(mmWriteComment.expectations) == 0 && mmWriteComment.defaultExpectation == nil && mmWriteComment.mock.funcWriteComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteComment.mock.afterWriteCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteComment implements users.Service
func (mmWriteComment *UsersMock) WriteComment(text *string, date time.Time, authorMail string, postId int) (err error) {
	mm_atomic.AddUint64(&mmWriteComment.beforeWriteCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteComment.afterWriteCommentCounter, 1)

	if mmWriteComment.inspectFuncWriteComment != nil {
		mmWriteComment.inspectFuncWriteComment(text, date, authorMail, postId)
	}

	mm_params := UsersMockWriteCommentParams{text, date, authorMail, postId}

	// Record call args
	mmWriteComment.WriteCommentMock.mutex.Lock()
	mmWriteComment.WriteCommentMock.callArgs = append(mmWriteComment.WriteCommentMock.callArgs, &mm_params)
	mmWriteComment.WriteCommentMock.mutex.Unlock()

	for _, e := range mmWriteComment.WriteCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWriteComment.WriteCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteComment.WriteCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteComment.WriteCommentMock.defaultExpectation.params
		mm_want_ptrs := mmWriteComment.WriteCommentMock.defaultExpectation.paramPtrs

		mm_got := UsersMockWriteCommentParams{text, date, authorMail, postId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmWriteComment.t.Errorf("UsersMock.WriteComment got unexpected parameter text, want: %#v, got: %#v%s\n", *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

			if mm_want_ptrs.date != nil && !minimock.Equal(*mm_want_ptrs.date, mm_got.date) {
				mmWriteComment.t.Errorf("UsersMock.WriteComment got unexpected parameter date, want: %#v, got: %#v%s\n", *mm_want_ptrs.date, mm_got.date, minimock.Diff(*mm_want_ptrs.date, mm_got.date))
			}

			if mm_want_ptrs.authorMail != nil && !minimock.Equal(*mm_want_ptrs.authorMail, mm_got.authorMail) {
				mmWriteComment.t.Errorf("UsersMock.WriteComment got unexpected parameter authorMail, want: %#v, got: %#v%s\n", *mm_want_ptrs.authorMail, mm_got.authorMail, minimock.Diff(*mm_want_ptrs.authorMail, mm_got.authorMail))
			}

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmWriteComment.t.Errorf("UsersMock.WriteComment got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteComment.t.Errorf("UsersMock.WriteComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteComment.WriteCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteComment.t.Fatal("No results are set for the UsersMock.WriteComment")
		}
		return (*mm_results).err
	}
	if mmWriteComment.funcWriteComment != nil {
		return mmWriteComment.funcWriteComment(text, date, authorMail, postId)
	}
	mmWriteComment.t.Fatalf("Unexpected call to UsersMock.WriteComment. %v %v %v %v", text, date, authorMail, postId)
	return
}

// WriteCommentAfterCounter returns a count of finished UsersMock.WriteComment invocations
func (mmWriteComment *UsersMock) WriteCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteComment.afterWriteCommentCounter)
}

// WriteCommentBeforeCounter returns a count of UsersMock.WriteComment invocations
func (mmWriteComment *UsersMock) WriteCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteComment.beforeWriteCommentCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.WriteComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteComment *mUsersMockWriteComment) Calls() []*UsersMockWriteCommentParams {
	mmWriteComment.mutex.RLock()

	argCopy := make([]*UsersMockWriteCommentParams, len(mmWriteComment.callArgs))
	copy(argCopy, mmWriteComment.callArgs)

	mmWriteComment.mutex.RUnlock()

	return argCopy
}

// MinimockWriteCommentDone returns true if the count of the WriteComment invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockWriteCommentDone() bool {
	if m.WriteCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteCommentMock.invocationsDone()
}

// MinimockWriteCommentInspect logs each unmet expectation
func (m *UsersMock) MinimockWriteCommentInspect() {
	for _, e := range m.WriteCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.WriteComment with params: %#v", *e.params)
		}
	}

	afterWriteCommentCounter := mm_atomic.LoadUint64(&m.afterWriteCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteCommentMock.defaultExpectation != nil && afterWriteCommentCounter < 1 {
		if m.WriteCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.WriteComment")
		} else {
			m.t.Errorf("Expected call to UsersMock.WriteComment with params: %#v", *m.WriteCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteComment != nil && afterWriteCommentCounter < 1 {
		m.t.Error("Expected call to UsersMock.WriteComment")
	}

	if !m.WriteCommentMock.invocationsDone() && afterWriteCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.WriteComment but found %d calls",
			mm_atomic.LoadUint64(&m.WriteCommentMock.expectedInvocations), afterWriteCommentCounter)
	}
}

type mUsersMockWritePost struct {
	optional           bool
	mock               *UsersMock
	defaultExpectation *UsersMockWritePostExpectation
	expectations       []*UsersMockWritePostExpectation

	callArgs []*UsersMockWritePostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UsersMockWritePostExpectation specifies expectation struct of the Service.WritePost
type UsersMockWritePostExpectation struct {
	mock      *UsersMock
	params    *UsersMockWritePostParams
	paramPtrs *UsersMockWritePostParamPtrs
	results   *UsersMockWritePostResults
	Counter   uint64
}

// UsersMockWritePostParams contains parameters of the Service.WritePost
type UsersMockWritePostParams struct {
	header     *string
	body       *string
	date       time.Time
	authorMail string
}

// UsersMockWritePostParamPtrs contains pointers to parameters of the Service.WritePost
type UsersMockWritePostParamPtrs struct {
	header     **string
	body       **string
	date       *time.Time
	authorMail *string
}

// UsersMockWritePostResults contains results of the Service.WritePost
type UsersMockWritePostResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWritePost *mUsersMockWritePost) Optional() *mUsersMockWritePost {
	mmWritePost.optional = true
	return mmWritePost
}

// Expect sets up expected params for Service.WritePost
func (mmWritePost *mUsersMockWritePost) Expect(header *string, body *string, date time.Time, authorMail string) *mUsersMockWritePost {
	if mmWritePost.mock.funcWritePost != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Set")
	}

	if mmWritePost.defaultExpectation == nil {
		mmWritePost.defaultExpectation = &UsersMockWritePostExpectation{}
	}

	if mmWritePost.defaultExpectation.paramPtrs != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by ExpectParams functions")
	}

	mmWritePost.defaultExpectation.params = &UsersMockWritePostParams{header, body, date, authorMail}
	for _, e := range mmWritePost.expectations {
		if minimock.Equal(e.params, mmWritePost.defaultExpectation.params) {
			mmWritePost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWritePost.defaultExpectation.params)
		}
	}

	return mmWritePost
}

// ExpectHeaderParam1 sets up expected param header for Service.WritePost
func (mmWritePost *mUsersMockWritePost) ExpectHeaderParam1(header *string) *mUsersMockWritePost {
	if mmWritePost.mock.funcWritePost != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Set")
	}

	if mmWritePost.defaultExpectation == nil {
		mmWritePost.defaultExpectation = &UsersMockWritePostExpectation{}
	}

	if mmWritePost.defaultExpectation.params != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Expect")
	}

	if mmWritePost.defaultExpectation.paramPtrs == nil {
		mmWritePost.defaultExpectation.paramPtrs = &UsersMockWritePostParamPtrs{}
	}
	mmWritePost.defaultExpectation.paramPtrs.header = &header

	return mmWritePost
}

// ExpectBodyParam2 sets up expected param body for Service.WritePost
func (mmWritePost *mUsersMockWritePost) ExpectBodyParam2(body *string) *mUsersMockWritePost {
	if mmWritePost.mock.funcWritePost != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Set")
	}

	if mmWritePost.defaultExpectation == nil {
		mmWritePost.defaultExpectation = &UsersMockWritePostExpectation{}
	}

	if mmWritePost.defaultExpectation.params != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Expect")
	}

	if mmWritePost.defaultExpectation.paramPtrs == nil {
		mmWritePost.defaultExpectation.paramPtrs = &UsersMockWritePostParamPtrs{}
	}
	mmWritePost.defaultExpectation.paramPtrs.body = &body

	return mmWritePost
}

// ExpectDateParam3 sets up expected param date for Service.WritePost
func (mmWritePost *mUsersMockWritePost) ExpectDateParam3(date time.Time) *mUsersMockWritePost {
	if mmWritePost.mock.funcWritePost != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Set")
	}

	if mmWritePost.defaultExpectation == nil {
		mmWritePost.defaultExpectation = &UsersMockWritePostExpectation{}
	}

	if mmWritePost.defaultExpectation.params != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Expect")
	}

	if mmWritePost.defaultExpectation.paramPtrs == nil {
		mmWritePost.defaultExpectation.paramPtrs = &UsersMockWritePostParamPtrs{}
	}
	mmWritePost.defaultExpectation.paramPtrs.date = &date

	return mmWritePost
}

// ExpectAuthorMailParam4 sets up expected param authorMail for Service.WritePost
func (mmWritePost *mUsersMockWritePost) ExpectAuthorMailParam4(authorMail string) *mUsersMockWritePost {
	if mmWritePost.mock.funcWritePost != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Set")
	}

	if mmWritePost.defaultExpectation == nil {
		mmWritePost.defaultExpectation = &UsersMockWritePostExpectation{}
	}

	if mmWritePost.defaultExpectation.params != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Expect")
	}

	if mmWritePost.defaultExpectation.paramPtrs == nil {
		mmWritePost.defaultExpectation.paramPtrs = &UsersMockWritePostParamPtrs{}
	}
	mmWritePost.defaultExpectation.paramPtrs.authorMail = &authorMail

	return mmWritePost
}

// Inspect accepts an inspector function that has same arguments as the Service.WritePost
func (mmWritePost *mUsersMockWritePost) Inspect(f func(header *string, body *string, date time.Time, authorMail string)) *mUsersMockWritePost {
	if mmWritePost.mock.inspectFuncWritePost != nil {
		mmWritePost.mock.t.Fatalf("Inspect function is already set for UsersMock.WritePost")
	}

	mmWritePost.mock.inspectFuncWritePost = f

	return mmWritePost
}

// Return sets up results that will be returned by Service.WritePost
func (mmWritePost *mUsersMockWritePost) Return(i1 int, err error) *UsersMock {
	if mmWritePost.mock.funcWritePost != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Set")
	}

	if mmWritePost.defaultExpectation == nil {
		mmWritePost.defaultExpectation = &UsersMockWritePostExpectation{mock: mmWritePost.mock}
	}
	mmWritePost.defaultExpectation.results = &UsersMockWritePostResults{i1, err}
	return mmWritePost.mock
}

// Set uses given function f to mock the Service.WritePost method
func (mmWritePost *mUsersMockWritePost) Set(f func(header *string, body *string, date time.Time, authorMail string) (i1 int, err error)) *UsersMock {
	if mmWritePost.defaultExpectation != nil {
		mmWritePost.mock.t.Fatalf("Default expectation is already set for the Service.WritePost method")
	}

	if len(mmWritePost.expectations) > 0 {
		mmWritePost.mock.t.Fatalf("Some expectations are already set for the Service.WritePost method")
	}

	mmWritePost.mock.funcWritePost = f
	return mmWritePost.mock
}

// When sets expectation for the Service.WritePost which will trigger the result defined by the following
// Then helper
func (mmWritePost *mUsersMockWritePost) When(header *string, body *string, date time.Time, authorMail string) *UsersMockWritePostExpectation {
	if mmWritePost.mock.funcWritePost != nil {
		mmWritePost.mock.t.Fatalf("UsersMock.WritePost mock is already set by Set")
	}

	expectation := &UsersMockWritePostExpectation{
		mock:   mmWritePost.mock,
		params: &UsersMockWritePostParams{header, body, date, authorMail},
	}
	mmWritePost.expectations = append(mmWritePost.expectations, expectation)
	return expectation
}

// Then sets up Service.WritePost return parameters for the expectation previously defined by the When method
func (e *UsersMockWritePostExpectation) Then(i1 int, err error) *UsersMock {
	e.results = &UsersMockWritePostResults{i1, err}
	return e.mock
}

// Times sets number of times Service.WritePost should be invoked
func (mmWritePost *mUsersMockWritePost) Times(n uint64) *mUsersMockWritePost {
	if n == 0 {
		mmWritePost.mock.t.Fatalf("Times of UsersMock.WritePost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWritePost.expectedInvocations, n)
	return mmWritePost
}

func (mmWritePost *mUsersMockWritePost) invocationsDone() bool {
	if len(mmWritePost.expectations) == 0 && mmWritePost.defaultExpectation == nil && mmWritePost.mock.funcWritePost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWritePost.mock.afterWritePostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWritePost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WritePost implements users.Service
func (mmWritePost *UsersMock) WritePost(header *string, body *string, date time.Time, authorMail string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmWritePost.beforeWritePostCounter, 1)
	defer mm_atomic.AddUint64(&mmWritePost.afterWritePostCounter, 1)

	if mmWritePost.inspectFuncWritePost != nil {
		mmWritePost.inspectFuncWritePost(header, body, date, authorMail)
	}

	mm_params := UsersMockWritePostParams{header, body, date, authorMail}

	// Record call args
	mmWritePost.WritePostMock.mutex.Lock()
	mmWritePost.WritePostMock.callArgs = append(mmWritePost.WritePostMock.callArgs, &mm_params)
	mmWritePost.WritePostMock.mutex.Unlock()

	for _, e := range mmWritePost.WritePostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmWritePost.WritePostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWritePost.WritePostMock.defaultExpectation.Counter, 1)
		mm_want := mmWritePost.WritePostMock.defaultExpectation.params
		mm_want_ptrs := mmWritePost.WritePostMock.defaultExpectation.paramPtrs

		mm_got := UsersMockWritePostParams{header, body, date, authorMail}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.header != nil && !minimock.Equal(*mm_want_ptrs.header, mm_got.header) {
				mmWritePost.t.Errorf("UsersMock.WritePost got unexpected parameter header, want: %#v, got: %#v%s\n", *mm_want_ptrs.header, mm_got.header, minimock.Diff(*mm_want_ptrs.header, mm_got.header))
			}

			if mm_want_ptrs.body != nil && !minimock.Equal(*mm_want_ptrs.body, mm_got.body) {
				mmWritePost.t.Errorf("UsersMock.WritePost got unexpected parameter body, want: %#v, got: %#v%s\n", *mm_want_ptrs.body, mm_got.body, minimock.Diff(*mm_want_ptrs.body, mm_got.body))
			}

			if mm_want_ptrs.date != nil && !minimock.Equal(*mm_want_ptrs.date, mm_got.date) {
				mmWritePost.t.Errorf("UsersMock.WritePost got unexpected parameter date, want: %#v, got: %#v%s\n", *mm_want_ptrs.date, mm_got.date, minimock.Diff(*mm_want_ptrs.date, mm_got.date))
			}

			if mm_want_ptrs.authorMail != nil && !minimock.Equal(*mm_want_ptrs.authorMail, mm_got.authorMail) {
				mmWritePost.t.Errorf("UsersMock.WritePost got unexpected parameter authorMail, want: %#v, got: %#v%s\n", *mm_want_ptrs.authorMail, mm_got.authorMail, minimock.Diff(*mm_want_ptrs.authorMail, mm_got.authorMail))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWritePost.t.Errorf("UsersMock.WritePost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWritePost.WritePostMock.defaultExpectation.results
		if mm_results == nil {
			mmWritePost.t.Fatal("No results are set for the UsersMock.WritePost")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmWritePost.funcWritePost != nil {
		return mmWritePost.funcWritePost(header, body, date, authorMail)
	}
	mmWritePost.t.Fatalf("Unexpected call to UsersMock.WritePost. %v %v %v %v", header, body, date, authorMail)
	return
}

// WritePostAfterCounter returns a count of finished UsersMock.WritePost invocations
func (mmWritePost *UsersMock) WritePostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWritePost.afterWritePostCounter)
}

// WritePostBeforeCounter returns a count of UsersMock.WritePost invocations
func (mmWritePost *UsersMock) WritePostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWritePost.beforeWritePostCounter)
}

// Calls returns a list of arguments used in each call to UsersMock.WritePost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWritePost *mUsersMockWritePost) Calls() []*UsersMockWritePostParams {
	mmWritePost.mutex.RLock()

	argCopy := make([]*UsersMockWritePostParams, len(mmWritePost.callArgs))
	copy(argCopy, mmWritePost.callArgs)

	mmWritePost.mutex.RUnlock()

	return argCopy
}

// MinimockWritePostDone returns true if the count of the WritePost invocations corresponds
// the number of defined expectations
func (m *UsersMock) MinimockWritePostDone() bool {
	if m.WritePostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WritePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WritePostMock.invocationsDone()
}

// MinimockWritePostInspect logs each unmet expectation
func (m *UsersMock) MinimockWritePostInspect() {
	for _, e := range m.WritePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersMock.WritePost with params: %#v", *e.params)
		}
	}

	afterWritePostCounter := mm_atomic.LoadUint64(&m.afterWritePostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WritePostMock.defaultExpectation != nil && afterWritePostCounter < 1 {
		if m.WritePostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersMock.WritePost")
		} else {
			m.t.Errorf("Expected call to UsersMock.WritePost with params: %#v", *m.WritePostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWritePost != nil && afterWritePostCounter < 1 {
		m.t.Error("Expected call to UsersMock.WritePost")
	}

	if !m.WritePostMock.invocationsDone() && afterWritePostCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersMock.WritePost but found %d calls",
			mm_atomic.LoadUint64(&m.WritePostMock.expectedInvocations), afterWritePostCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UsersMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAuthorizationInspect()

			m.MinimockDeleteCommentInspect()

			m.MinimockDeletePostInspect()

			m.MinimockEditPostInspect()

			m.MinimockGetCommentInspect()

			m.MinimockGetCommentsInspect()

			m.MinimockGetPostInspect()

			m.MinimockGetPostsInspect()

			m.MinimockGetProfileInspect()

			m.MinimockRegisterInspect()

			m.MinimockWriteCommentInspect()

			m.MinimockWritePostInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UsersMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UsersMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAuthorizationDone() &&
		m.MinimockDeleteCommentDone() &&
		m.MinimockDeletePostDone() &&
		m.MinimockEditPostDone() &&
		m.MinimockGetCommentDone() &&
		m.MinimockGetCommentsDone() &&
		m.MinimockGetPostDone() &&
		m.MinimockGetPostsDone() &&
		m.MinimockGetProfileDone() &&
		m.MinimockRegisterDone() &&
		m.MinimockWriteCommentDone() &&
		m.MinimockWritePostDone()
}

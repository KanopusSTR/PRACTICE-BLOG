// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package minimock

//go:generate minimock -i server/internal/repo.Comment -o mock_comment.go -n CommentMock -p minimock

import (
	"server/internal/entities"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CommentMock implements repo.Comment
type CommentMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(text *string, date time.Time, authorMail string, postId int) (err error)
	inspectFuncAdd   func(text *string, date time.Time, authorMail string, postId int)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mCommentMockAdd

	funcGetPostComment          func(postId int, commentId int) (cp1 *entities.Comment, err error)
	inspectFuncGetPostComment   func(postId int, commentId int)
	afterGetPostCommentCounter  uint64
	beforeGetPostCommentCounter uint64
	GetPostCommentMock          mCommentMockGetPostComment

	funcGetPostComments          func(postId int) (pa1 []interface{}, err error)
	inspectFuncGetPostComments   func(postId int)
	afterGetPostCommentsCounter  uint64
	beforeGetPostCommentsCounter uint64
	GetPostCommentsMock          mCommentMockGetPostComments

	funcRemove          func(postId int, commentId int) (err error)
	inspectFuncRemove   func(postId int, commentId int)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mCommentMockRemove
}

// NewCommentMock returns a mock for repo.Comment
func NewCommentMock(t minimock.Tester) *CommentMock {
	m := &CommentMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mCommentMockAdd{mock: m}
	m.AddMock.callArgs = []*CommentMockAddParams{}

	m.GetPostCommentMock = mCommentMockGetPostComment{mock: m}
	m.GetPostCommentMock.callArgs = []*CommentMockGetPostCommentParams{}

	m.GetPostCommentsMock = mCommentMockGetPostComments{mock: m}
	m.GetPostCommentsMock.callArgs = []*CommentMockGetPostCommentsParams{}

	m.RemoveMock = mCommentMockRemove{mock: m}
	m.RemoveMock.callArgs = []*CommentMockRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCommentMockAdd struct {
	optional           bool
	mock               *CommentMock
	defaultExpectation *CommentMockAddExpectation
	expectations       []*CommentMockAddExpectation

	callArgs []*CommentMockAddParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentMockAddExpectation specifies expectation struct of the Comment.Add
type CommentMockAddExpectation struct {
	mock      *CommentMock
	params    *CommentMockAddParams
	paramPtrs *CommentMockAddParamPtrs
	results   *CommentMockAddResults
	Counter   uint64
}

// CommentMockAddParams contains parameters of the Comment.Add
type CommentMockAddParams struct {
	text       *string
	date       time.Time
	authorMail string
	postId     int
}

// CommentMockAddParamPtrs contains pointers to parameters of the Comment.Add
type CommentMockAddParamPtrs struct {
	text       **string
	date       *time.Time
	authorMail *string
	postId     *int
}

// CommentMockAddResults contains results of the Comment.Add
type CommentMockAddResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mCommentMockAdd) Optional() *mCommentMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for Comment.Add
func (mmAdd *mCommentMockAdd) Expect(text *string, date time.Time, authorMail string, postId int) *mCommentMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &CommentMockAddParams{text, date, authorMail, postId}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectTextParam1 sets up expected param text for Comment.Add
func (mmAdd *mCommentMockAdd) ExpectTextParam1(text *string) *mCommentMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CommentMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.text = &text

	return mmAdd
}

// ExpectDateParam2 sets up expected param date for Comment.Add
func (mmAdd *mCommentMockAdd) ExpectDateParam2(date time.Time) *mCommentMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CommentMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.date = &date

	return mmAdd
}

// ExpectAuthorMailParam3 sets up expected param authorMail for Comment.Add
func (mmAdd *mCommentMockAdd) ExpectAuthorMailParam3(authorMail string) *mCommentMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CommentMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.authorMail = &authorMail

	return mmAdd
}

// ExpectPostIdParam4 sets up expected param postId for Comment.Add
func (mmAdd *mCommentMockAdd) ExpectPostIdParam4(postId int) *mCommentMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CommentMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.postId = &postId

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the Comment.Add
func (mmAdd *mCommentMockAdd) Inspect(f func(text *string, date time.Time, authorMail string, postId int)) *mCommentMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for CommentMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by Comment.Add
func (mmAdd *mCommentMockAdd) Return(err error) *CommentMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &CommentMockAddResults{err}
	return mmAdd.mock
}

// Set uses given function f to mock the Comment.Add method
func (mmAdd *mCommentMockAdd) Set(f func(text *string, date time.Time, authorMail string, postId int) (err error)) *CommentMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the Comment.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the Comment.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the Comment.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mCommentMockAdd) When(text *string, date time.Time, authorMail string, postId int) *CommentMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentMock.Add mock is already set by Set")
	}

	expectation := &CommentMockAddExpectation{
		mock:   mmAdd.mock,
		params: &CommentMockAddParams{text, date, authorMail, postId},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up Comment.Add return parameters for the expectation previously defined by the When method
func (e *CommentMockAddExpectation) Then(err error) *CommentMock {
	e.results = &CommentMockAddResults{err}
	return e.mock
}

// Times sets number of times Comment.Add should be invoked
func (mmAdd *mCommentMockAdd) Times(n uint64) *mCommentMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of CommentMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	return mmAdd
}

func (mmAdd *mCommentMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements repo.Comment
func (mmAdd *CommentMock) Add(text *string, date time.Time, authorMail string, postId int) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(text, date, authorMail, postId)
	}

	mm_params := CommentMockAddParams{text, date, authorMail, postId}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := CommentMockAddParams{text, date, authorMail, postId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmAdd.t.Errorf("CommentMock.Add got unexpected parameter text, want: %#v, got: %#v%s\n", *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

			if mm_want_ptrs.date != nil && !minimock.Equal(*mm_want_ptrs.date, mm_got.date) {
				mmAdd.t.Errorf("CommentMock.Add got unexpected parameter date, want: %#v, got: %#v%s\n", *mm_want_ptrs.date, mm_got.date, minimock.Diff(*mm_want_ptrs.date, mm_got.date))
			}

			if mm_want_ptrs.authorMail != nil && !minimock.Equal(*mm_want_ptrs.authorMail, mm_got.authorMail) {
				mmAdd.t.Errorf("CommentMock.Add got unexpected parameter authorMail, want: %#v, got: %#v%s\n", *mm_want_ptrs.authorMail, mm_got.authorMail, minimock.Diff(*mm_want_ptrs.authorMail, mm_got.authorMail))
			}

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmAdd.t.Errorf("CommentMock.Add got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("CommentMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the CommentMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(text, date, authorMail, postId)
	}
	mmAdd.t.Fatalf("Unexpected call to CommentMock.Add. %v %v %v %v", text, date, authorMail, postId)
	return
}

// AddAfterCounter returns a count of finished CommentMock.Add invocations
func (mmAdd *CommentMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of CommentMock.Add invocations
func (mmAdd *CommentMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to CommentMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mCommentMockAdd) Calls() []*CommentMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*CommentMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *CommentMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *CommentMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentMock.Add with params: %#v", *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentMock.Add")
		} else {
			m.t.Errorf("Expected call to CommentMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Error("Expected call to CommentMock.Add")
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentMock.Add but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), afterAddCounter)
	}
}

type mCommentMockGetPostComment struct {
	optional           bool
	mock               *CommentMock
	defaultExpectation *CommentMockGetPostCommentExpectation
	expectations       []*CommentMockGetPostCommentExpectation

	callArgs []*CommentMockGetPostCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentMockGetPostCommentExpectation specifies expectation struct of the Comment.GetPostComment
type CommentMockGetPostCommentExpectation struct {
	mock      *CommentMock
	params    *CommentMockGetPostCommentParams
	paramPtrs *CommentMockGetPostCommentParamPtrs
	results   *CommentMockGetPostCommentResults
	Counter   uint64
}

// CommentMockGetPostCommentParams contains parameters of the Comment.GetPostComment
type CommentMockGetPostCommentParams struct {
	postId    int
	commentId int
}

// CommentMockGetPostCommentParamPtrs contains pointers to parameters of the Comment.GetPostComment
type CommentMockGetPostCommentParamPtrs struct {
	postId    *int
	commentId *int
}

// CommentMockGetPostCommentResults contains results of the Comment.GetPostComment
type CommentMockGetPostCommentResults struct {
	cp1 *entities.Comment
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPostComment *mCommentMockGetPostComment) Optional() *mCommentMockGetPostComment {
	mmGetPostComment.optional = true
	return mmGetPostComment
}

// Expect sets up expected params for Comment.GetPostComment
func (mmGetPostComment *mCommentMockGetPostComment) Expect(postId int, commentId int) *mCommentMockGetPostComment {
	if mmGetPostComment.mock.funcGetPostComment != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by Set")
	}

	if mmGetPostComment.defaultExpectation == nil {
		mmGetPostComment.defaultExpectation = &CommentMockGetPostCommentExpectation{}
	}

	if mmGetPostComment.defaultExpectation.paramPtrs != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by ExpectParams functions")
	}

	mmGetPostComment.defaultExpectation.params = &CommentMockGetPostCommentParams{postId, commentId}
	for _, e := range mmGetPostComment.expectations {
		if minimock.Equal(e.params, mmGetPostComment.defaultExpectation.params) {
			mmGetPostComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostComment.defaultExpectation.params)
		}
	}

	return mmGetPostComment
}

// ExpectPostIdParam1 sets up expected param postId for Comment.GetPostComment
func (mmGetPostComment *mCommentMockGetPostComment) ExpectPostIdParam1(postId int) *mCommentMockGetPostComment {
	if mmGetPostComment.mock.funcGetPostComment != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by Set")
	}

	if mmGetPostComment.defaultExpectation == nil {
		mmGetPostComment.defaultExpectation = &CommentMockGetPostCommentExpectation{}
	}

	if mmGetPostComment.defaultExpectation.params != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by Expect")
	}

	if mmGetPostComment.defaultExpectation.paramPtrs == nil {
		mmGetPostComment.defaultExpectation.paramPtrs = &CommentMockGetPostCommentParamPtrs{}
	}
	mmGetPostComment.defaultExpectation.paramPtrs.postId = &postId

	return mmGetPostComment
}

// ExpectCommentIdParam2 sets up expected param commentId for Comment.GetPostComment
func (mmGetPostComment *mCommentMockGetPostComment) ExpectCommentIdParam2(commentId int) *mCommentMockGetPostComment {
	if mmGetPostComment.mock.funcGetPostComment != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by Set")
	}

	if mmGetPostComment.defaultExpectation == nil {
		mmGetPostComment.defaultExpectation = &CommentMockGetPostCommentExpectation{}
	}

	if mmGetPostComment.defaultExpectation.params != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by Expect")
	}

	if mmGetPostComment.defaultExpectation.paramPtrs == nil {
		mmGetPostComment.defaultExpectation.paramPtrs = &CommentMockGetPostCommentParamPtrs{}
	}
	mmGetPostComment.defaultExpectation.paramPtrs.commentId = &commentId

	return mmGetPostComment
}

// Inspect accepts an inspector function that has same arguments as the Comment.GetPostComment
func (mmGetPostComment *mCommentMockGetPostComment) Inspect(f func(postId int, commentId int)) *mCommentMockGetPostComment {
	if mmGetPostComment.mock.inspectFuncGetPostComment != nil {
		mmGetPostComment.mock.t.Fatalf("Inspect function is already set for CommentMock.GetPostComment")
	}

	mmGetPostComment.mock.inspectFuncGetPostComment = f

	return mmGetPostComment
}

// Return sets up results that will be returned by Comment.GetPostComment
func (mmGetPostComment *mCommentMockGetPostComment) Return(cp1 *entities.Comment, err error) *CommentMock {
	if mmGetPostComment.mock.funcGetPostComment != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by Set")
	}

	if mmGetPostComment.defaultExpectation == nil {
		mmGetPostComment.defaultExpectation = &CommentMockGetPostCommentExpectation{mock: mmGetPostComment.mock}
	}
	mmGetPostComment.defaultExpectation.results = &CommentMockGetPostCommentResults{cp1, err}
	return mmGetPostComment.mock
}

// Set uses given function f to mock the Comment.GetPostComment method
func (mmGetPostComment *mCommentMockGetPostComment) Set(f func(postId int, commentId int) (cp1 *entities.Comment, err error)) *CommentMock {
	if mmGetPostComment.defaultExpectation != nil {
		mmGetPostComment.mock.t.Fatalf("Default expectation is already set for the Comment.GetPostComment method")
	}

	if len(mmGetPostComment.expectations) > 0 {
		mmGetPostComment.mock.t.Fatalf("Some expectations are already set for the Comment.GetPostComment method")
	}

	mmGetPostComment.mock.funcGetPostComment = f
	return mmGetPostComment.mock
}

// When sets expectation for the Comment.GetPostComment which will trigger the result defined by the following
// Then helper
func (mmGetPostComment *mCommentMockGetPostComment) When(postId int, commentId int) *CommentMockGetPostCommentExpectation {
	if mmGetPostComment.mock.funcGetPostComment != nil {
		mmGetPostComment.mock.t.Fatalf("CommentMock.GetPostComment mock is already set by Set")
	}

	expectation := &CommentMockGetPostCommentExpectation{
		mock:   mmGetPostComment.mock,
		params: &CommentMockGetPostCommentParams{postId, commentId},
	}
	mmGetPostComment.expectations = append(mmGetPostComment.expectations, expectation)
	return expectation
}

// Then sets up Comment.GetPostComment return parameters for the expectation previously defined by the When method
func (e *CommentMockGetPostCommentExpectation) Then(cp1 *entities.Comment, err error) *CommentMock {
	e.results = &CommentMockGetPostCommentResults{cp1, err}
	return e.mock
}

// Times sets number of times Comment.GetPostComment should be invoked
func (mmGetPostComment *mCommentMockGetPostComment) Times(n uint64) *mCommentMockGetPostComment {
	if n == 0 {
		mmGetPostComment.mock.t.Fatalf("Times of CommentMock.GetPostComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPostComment.expectedInvocations, n)
	return mmGetPostComment
}

func (mmGetPostComment *mCommentMockGetPostComment) invocationsDone() bool {
	if len(mmGetPostComment.expectations) == 0 && mmGetPostComment.defaultExpectation == nil && mmGetPostComment.mock.funcGetPostComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPostComment.mock.afterGetPostCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPostComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPostComment implements repo.Comment
func (mmGetPostComment *CommentMock) GetPostComment(postId int, commentId int) (cp1 *entities.Comment, err error) {
	mm_atomic.AddUint64(&mmGetPostComment.beforeGetPostCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostComment.afterGetPostCommentCounter, 1)

	if mmGetPostComment.inspectFuncGetPostComment != nil {
		mmGetPostComment.inspectFuncGetPostComment(postId, commentId)
	}

	mm_params := CommentMockGetPostCommentParams{postId, commentId}

	// Record call args
	mmGetPostComment.GetPostCommentMock.mutex.Lock()
	mmGetPostComment.GetPostCommentMock.callArgs = append(mmGetPostComment.GetPostCommentMock.callArgs, &mm_params)
	mmGetPostComment.GetPostCommentMock.mutex.Unlock()

	for _, e := range mmGetPostComment.GetPostCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetPostComment.GetPostCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostComment.GetPostCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostComment.GetPostCommentMock.defaultExpectation.params
		mm_want_ptrs := mmGetPostComment.GetPostCommentMock.defaultExpectation.paramPtrs

		mm_got := CommentMockGetPostCommentParams{postId, commentId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmGetPostComment.t.Errorf("CommentMock.GetPostComment got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

			if mm_want_ptrs.commentId != nil && !minimock.Equal(*mm_want_ptrs.commentId, mm_got.commentId) {
				mmGetPostComment.t.Errorf("CommentMock.GetPostComment got unexpected parameter commentId, want: %#v, got: %#v%s\n", *mm_want_ptrs.commentId, mm_got.commentId, minimock.Diff(*mm_want_ptrs.commentId, mm_got.commentId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostComment.t.Errorf("CommentMock.GetPostComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostComment.GetPostCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostComment.t.Fatal("No results are set for the CommentMock.GetPostComment")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetPostComment.funcGetPostComment != nil {
		return mmGetPostComment.funcGetPostComment(postId, commentId)
	}
	mmGetPostComment.t.Fatalf("Unexpected call to CommentMock.GetPostComment. %v %v", postId, commentId)
	return
}

// GetPostCommentAfterCounter returns a count of finished CommentMock.GetPostComment invocations
func (mmGetPostComment *CommentMock) GetPostCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostComment.afterGetPostCommentCounter)
}

// GetPostCommentBeforeCounter returns a count of CommentMock.GetPostComment invocations
func (mmGetPostComment *CommentMock) GetPostCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostComment.beforeGetPostCommentCounter)
}

// Calls returns a list of arguments used in each call to CommentMock.GetPostComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostComment *mCommentMockGetPostComment) Calls() []*CommentMockGetPostCommentParams {
	mmGetPostComment.mutex.RLock()

	argCopy := make([]*CommentMockGetPostCommentParams, len(mmGetPostComment.callArgs))
	copy(argCopy, mmGetPostComment.callArgs)

	mmGetPostComment.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostCommentDone returns true if the count of the GetPostComment invocations corresponds
// the number of defined expectations
func (m *CommentMock) MinimockGetPostCommentDone() bool {
	if m.GetPostCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostCommentMock.invocationsDone()
}

// MinimockGetPostCommentInspect logs each unmet expectation
func (m *CommentMock) MinimockGetPostCommentInspect() {
	for _, e := range m.GetPostCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentMock.GetPostComment with params: %#v", *e.params)
		}
	}

	afterGetPostCommentCounter := mm_atomic.LoadUint64(&m.afterGetPostCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostCommentMock.defaultExpectation != nil && afterGetPostCommentCounter < 1 {
		if m.GetPostCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentMock.GetPostComment")
		} else {
			m.t.Errorf("Expected call to CommentMock.GetPostComment with params: %#v", *m.GetPostCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostComment != nil && afterGetPostCommentCounter < 1 {
		m.t.Error("Expected call to CommentMock.GetPostComment")
	}

	if !m.GetPostCommentMock.invocationsDone() && afterGetPostCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentMock.GetPostComment but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostCommentMock.expectedInvocations), afterGetPostCommentCounter)
	}
}

type mCommentMockGetPostComments struct {
	optional           bool
	mock               *CommentMock
	defaultExpectation *CommentMockGetPostCommentsExpectation
	expectations       []*CommentMockGetPostCommentsExpectation

	callArgs []*CommentMockGetPostCommentsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentMockGetPostCommentsExpectation specifies expectation struct of the Comment.GetPostComments
type CommentMockGetPostCommentsExpectation struct {
	mock      *CommentMock
	params    *CommentMockGetPostCommentsParams
	paramPtrs *CommentMockGetPostCommentsParamPtrs
	results   *CommentMockGetPostCommentsResults
	Counter   uint64
}

// CommentMockGetPostCommentsParams contains parameters of the Comment.GetPostComments
type CommentMockGetPostCommentsParams struct {
	postId int
}

// CommentMockGetPostCommentsParamPtrs contains pointers to parameters of the Comment.GetPostComments
type CommentMockGetPostCommentsParamPtrs struct {
	postId *int
}

// CommentMockGetPostCommentsResults contains results of the Comment.GetPostComments
type CommentMockGetPostCommentsResults struct {
	pa1 []interface{}
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPostComments *mCommentMockGetPostComments) Optional() *mCommentMockGetPostComments {
	mmGetPostComments.optional = true
	return mmGetPostComments
}

// Expect sets up expected params for Comment.GetPostComments
func (mmGetPostComments *mCommentMockGetPostComments) Expect(postId int) *mCommentMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.paramPtrs != nil {
		mmGetPostComments.mock.t.Fatalf("CommentMock.GetPostComments mock is already set by ExpectParams functions")
	}

	mmGetPostComments.defaultExpectation.params = &CommentMockGetPostCommentsParams{postId}
	for _, e := range mmGetPostComments.expectations {
		if minimock.Equal(e.params, mmGetPostComments.defaultExpectation.params) {
			mmGetPostComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostComments.defaultExpectation.params)
		}
	}

	return mmGetPostComments
}

// ExpectPostIdParam1 sets up expected param postId for Comment.GetPostComments
func (mmGetPostComments *mCommentMockGetPostComments) ExpectPostIdParam1(postId int) *mCommentMockGetPostComments {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentMockGetPostCommentsExpectation{}
	}

	if mmGetPostComments.defaultExpectation.params != nil {
		mmGetPostComments.mock.t.Fatalf("CommentMock.GetPostComments mock is already set by Expect")
	}

	if mmGetPostComments.defaultExpectation.paramPtrs == nil {
		mmGetPostComments.defaultExpectation.paramPtrs = &CommentMockGetPostCommentsParamPtrs{}
	}
	mmGetPostComments.defaultExpectation.paramPtrs.postId = &postId

	return mmGetPostComments
}

// Inspect accepts an inspector function that has same arguments as the Comment.GetPostComments
func (mmGetPostComments *mCommentMockGetPostComments) Inspect(f func(postId int)) *mCommentMockGetPostComments {
	if mmGetPostComments.mock.inspectFuncGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("Inspect function is already set for CommentMock.GetPostComments")
	}

	mmGetPostComments.mock.inspectFuncGetPostComments = f

	return mmGetPostComments
}

// Return sets up results that will be returned by Comment.GetPostComments
func (mmGetPostComments *mCommentMockGetPostComments) Return(pa1 []interface{}, err error) *CommentMock {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentMock.GetPostComments mock is already set by Set")
	}

	if mmGetPostComments.defaultExpectation == nil {
		mmGetPostComments.defaultExpectation = &CommentMockGetPostCommentsExpectation{mock: mmGetPostComments.mock}
	}
	mmGetPostComments.defaultExpectation.results = &CommentMockGetPostCommentsResults{pa1, err}
	return mmGetPostComments.mock
}

// Set uses given function f to mock the Comment.GetPostComments method
func (mmGetPostComments *mCommentMockGetPostComments) Set(f func(postId int) (pa1 []interface{}, err error)) *CommentMock {
	if mmGetPostComments.defaultExpectation != nil {
		mmGetPostComments.mock.t.Fatalf("Default expectation is already set for the Comment.GetPostComments method")
	}

	if len(mmGetPostComments.expectations) > 0 {
		mmGetPostComments.mock.t.Fatalf("Some expectations are already set for the Comment.GetPostComments method")
	}

	mmGetPostComments.mock.funcGetPostComments = f
	return mmGetPostComments.mock
}

// When sets expectation for the Comment.GetPostComments which will trigger the result defined by the following
// Then helper
func (mmGetPostComments *mCommentMockGetPostComments) When(postId int) *CommentMockGetPostCommentsExpectation {
	if mmGetPostComments.mock.funcGetPostComments != nil {
		mmGetPostComments.mock.t.Fatalf("CommentMock.GetPostComments mock is already set by Set")
	}

	expectation := &CommentMockGetPostCommentsExpectation{
		mock:   mmGetPostComments.mock,
		params: &CommentMockGetPostCommentsParams{postId},
	}
	mmGetPostComments.expectations = append(mmGetPostComments.expectations, expectation)
	return expectation
}

// Then sets up Comment.GetPostComments return parameters for the expectation previously defined by the When method
func (e *CommentMockGetPostCommentsExpectation) Then(pa1 []interface{}, err error) *CommentMock {
	e.results = &CommentMockGetPostCommentsResults{pa1, err}
	return e.mock
}

// Times sets number of times Comment.GetPostComments should be invoked
func (mmGetPostComments *mCommentMockGetPostComments) Times(n uint64) *mCommentMockGetPostComments {
	if n == 0 {
		mmGetPostComments.mock.t.Fatalf("Times of CommentMock.GetPostComments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPostComments.expectedInvocations, n)
	return mmGetPostComments
}

func (mmGetPostComments *mCommentMockGetPostComments) invocationsDone() bool {
	if len(mmGetPostComments.expectations) == 0 && mmGetPostComments.defaultExpectation == nil && mmGetPostComments.mock.funcGetPostComments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPostComments.mock.afterGetPostCommentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPostComments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPostComments implements repo.Comment
func (mmGetPostComments *CommentMock) GetPostComments(postId int) (pa1 []interface{}, err error) {
	mm_atomic.AddUint64(&mmGetPostComments.beforeGetPostCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostComments.afterGetPostCommentsCounter, 1)

	if mmGetPostComments.inspectFuncGetPostComments != nil {
		mmGetPostComments.inspectFuncGetPostComments(postId)
	}

	mm_params := CommentMockGetPostCommentsParams{postId}

	// Record call args
	mmGetPostComments.GetPostCommentsMock.mutex.Lock()
	mmGetPostComments.GetPostCommentsMock.callArgs = append(mmGetPostComments.GetPostCommentsMock.callArgs, &mm_params)
	mmGetPostComments.GetPostCommentsMock.mutex.Unlock()

	for _, e := range mmGetPostComments.GetPostCommentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetPostComments.GetPostCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostComments.GetPostCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostComments.GetPostCommentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPostComments.GetPostCommentsMock.defaultExpectation.paramPtrs

		mm_got := CommentMockGetPostCommentsParams{postId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmGetPostComments.t.Errorf("CommentMock.GetPostComments got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostComments.t.Errorf("CommentMock.GetPostComments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostComments.GetPostCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostComments.t.Fatal("No results are set for the CommentMock.GetPostComments")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetPostComments.funcGetPostComments != nil {
		return mmGetPostComments.funcGetPostComments(postId)
	}
	mmGetPostComments.t.Fatalf("Unexpected call to CommentMock.GetPostComments. %v", postId)
	return
}

// GetPostCommentsAfterCounter returns a count of finished CommentMock.GetPostComments invocations
func (mmGetPostComments *CommentMock) GetPostCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostComments.afterGetPostCommentsCounter)
}

// GetPostCommentsBeforeCounter returns a count of CommentMock.GetPostComments invocations
func (mmGetPostComments *CommentMock) GetPostCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostComments.beforeGetPostCommentsCounter)
}

// Calls returns a list of arguments used in each call to CommentMock.GetPostComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostComments *mCommentMockGetPostComments) Calls() []*CommentMockGetPostCommentsParams {
	mmGetPostComments.mutex.RLock()

	argCopy := make([]*CommentMockGetPostCommentsParams, len(mmGetPostComments.callArgs))
	copy(argCopy, mmGetPostComments.callArgs)

	mmGetPostComments.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostCommentsDone returns true if the count of the GetPostComments invocations corresponds
// the number of defined expectations
func (m *CommentMock) MinimockGetPostCommentsDone() bool {
	if m.GetPostCommentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostCommentsMock.invocationsDone()
}

// MinimockGetPostCommentsInspect logs each unmet expectation
func (m *CommentMock) MinimockGetPostCommentsInspect() {
	for _, e := range m.GetPostCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentMock.GetPostComments with params: %#v", *e.params)
		}
	}

	afterGetPostCommentsCounter := mm_atomic.LoadUint64(&m.afterGetPostCommentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostCommentsMock.defaultExpectation != nil && afterGetPostCommentsCounter < 1 {
		if m.GetPostCommentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentMock.GetPostComments")
		} else {
			m.t.Errorf("Expected call to CommentMock.GetPostComments with params: %#v", *m.GetPostCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostComments != nil && afterGetPostCommentsCounter < 1 {
		m.t.Error("Expected call to CommentMock.GetPostComments")
	}

	if !m.GetPostCommentsMock.invocationsDone() && afterGetPostCommentsCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentMock.GetPostComments but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostCommentsMock.expectedInvocations), afterGetPostCommentsCounter)
	}
}

type mCommentMockRemove struct {
	optional           bool
	mock               *CommentMock
	defaultExpectation *CommentMockRemoveExpectation
	expectations       []*CommentMockRemoveExpectation

	callArgs []*CommentMockRemoveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CommentMockRemoveExpectation specifies expectation struct of the Comment.Remove
type CommentMockRemoveExpectation struct {
	mock      *CommentMock
	params    *CommentMockRemoveParams
	paramPtrs *CommentMockRemoveParamPtrs
	results   *CommentMockRemoveResults
	Counter   uint64
}

// CommentMockRemoveParams contains parameters of the Comment.Remove
type CommentMockRemoveParams struct {
	postId    int
	commentId int
}

// CommentMockRemoveParamPtrs contains pointers to parameters of the Comment.Remove
type CommentMockRemoveParamPtrs struct {
	postId    *int
	commentId *int
}

// CommentMockRemoveResults contains results of the Comment.Remove
type CommentMockRemoveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemove *mCommentMockRemove) Optional() *mCommentMockRemove {
	mmRemove.optional = true
	return mmRemove
}

// Expect sets up expected params for Comment.Remove
func (mmRemove *mCommentMockRemove) Expect(postId int, commentId int) *mCommentMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &CommentMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.paramPtrs != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by ExpectParams functions")
	}

	mmRemove.defaultExpectation.params = &CommentMockRemoveParams{postId, commentId}
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// ExpectPostIdParam1 sets up expected param postId for Comment.Remove
func (mmRemove *mCommentMockRemove) ExpectPostIdParam1(postId int) *mCommentMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &CommentMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &CommentMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.postId = &postId

	return mmRemove
}

// ExpectCommentIdParam2 sets up expected param commentId for Comment.Remove
func (mmRemove *mCommentMockRemove) ExpectCommentIdParam2(commentId int) *mCommentMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &CommentMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &CommentMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.commentId = &commentId

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the Comment.Remove
func (mmRemove *mCommentMockRemove) Inspect(f func(postId int, commentId int)) *mCommentMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for CommentMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by Comment.Remove
func (mmRemove *mCommentMockRemove) Return(err error) *CommentMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &CommentMockRemoveExpectation{mock: mmRemove.mock}
	}
	mmRemove.defaultExpectation.results = &CommentMockRemoveResults{err}
	return mmRemove.mock
}

// Set uses given function f to mock the Comment.Remove method
func (mmRemove *mCommentMockRemove) Set(f func(postId int, commentId int) (err error)) *CommentMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the Comment.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the Comment.Remove method")
	}

	mmRemove.mock.funcRemove = f
	return mmRemove.mock
}

// When sets expectation for the Comment.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mCommentMockRemove) When(postId int, commentId int) *CommentMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("CommentMock.Remove mock is already set by Set")
	}

	expectation := &CommentMockRemoveExpectation{
		mock:   mmRemove.mock,
		params: &CommentMockRemoveParams{postId, commentId},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up Comment.Remove return parameters for the expectation previously defined by the When method
func (e *CommentMockRemoveExpectation) Then(err error) *CommentMock {
	e.results = &CommentMockRemoveResults{err}
	return e.mock
}

// Times sets number of times Comment.Remove should be invoked
func (mmRemove *mCommentMockRemove) Times(n uint64) *mCommentMockRemove {
	if n == 0 {
		mmRemove.mock.t.Fatalf("Times of CommentMock.Remove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemove.expectedInvocations, n)
	return mmRemove
}

func (mmRemove *mCommentMockRemove) invocationsDone() bool {
	if len(mmRemove.expectations) == 0 && mmRemove.defaultExpectation == nil && mmRemove.mock.funcRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemove.mock.afterRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Remove implements repo.Comment
func (mmRemove *CommentMock) Remove(postId int, commentId int) (err error) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(postId, commentId)
	}

	mm_params := CommentMockRemoveParams{postId, commentId}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, &mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_want_ptrs := mmRemove.RemoveMock.defaultExpectation.paramPtrs

		mm_got := CommentMockRemoveParams{postId, commentId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.postId != nil && !minimock.Equal(*mm_want_ptrs.postId, mm_got.postId) {
				mmRemove.t.Errorf("CommentMock.Remove got unexpected parameter postId, want: %#v, got: %#v%s\n", *mm_want_ptrs.postId, mm_got.postId, minimock.Diff(*mm_want_ptrs.postId, mm_got.postId))
			}

			if mm_want_ptrs.commentId != nil && !minimock.Equal(*mm_want_ptrs.commentId, mm_got.commentId) {
				mmRemove.t.Errorf("CommentMock.Remove got unexpected parameter commentId, want: %#v, got: %#v%s\n", *mm_want_ptrs.commentId, mm_got.commentId, minimock.Diff(*mm_want_ptrs.commentId, mm_got.commentId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("CommentMock.Remove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemove.RemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmRemove.t.Fatal("No results are set for the CommentMock.Remove")
		}
		return (*mm_results).err
	}
	if mmRemove.funcRemove != nil {
		return mmRemove.funcRemove(postId, commentId)
	}
	mmRemove.t.Fatalf("Unexpected call to CommentMock.Remove. %v %v", postId, commentId)
	return
}

// RemoveAfterCounter returns a count of finished CommentMock.Remove invocations
func (mmRemove *CommentMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of CommentMock.Remove invocations
func (mmRemove *CommentMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to CommentMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mCommentMockRemove) Calls() []*CommentMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*CommentMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *CommentMock) MinimockRemoveDone() bool {
	if m.RemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveMock.invocationsDone()
}

// MinimockRemoveInspect logs each unmet expectation
func (m *CommentMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentMock.Remove with params: %#v", *e.params)
		}
	}

	afterRemoveCounter := mm_atomic.LoadUint64(&m.afterRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && afterRemoveCounter < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentMock.Remove")
		} else {
			m.t.Errorf("Expected call to CommentMock.Remove with params: %#v", *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && afterRemoveCounter < 1 {
		m.t.Error("Expected call to CommentMock.Remove")
	}

	if !m.RemoveMock.invocationsDone() && afterRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentMock.Remove but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveMock.expectedInvocations), afterRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommentMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockGetPostCommentInspect()

			m.MinimockGetPostCommentsInspect()

			m.MinimockRemoveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockGetPostCommentDone() &&
		m.MinimockGetPostCommentsDone() &&
		m.MinimockRemoveDone()
}
